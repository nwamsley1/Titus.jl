var documenterSearchIndex = {"docs":
[{"location":"introduction/","page":"Introduction","title":"Introduction","text":"CurrentModule = Titus","category":"page"},{"location":"introduction/#Titus","page":"Introduction","title":"Titus","text":"","category":"section"},{"location":"introduction/","page":"Introduction","title":"Introduction","text":"Documentation for Titus.","category":"page"},{"location":"introduction/#A-Header","page":"Introduction","title":"A Header","text":"","category":"section"},{"location":"introduction/#Another-Header","page":"Introduction","title":"Another Header","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"CurrentModule = Titus","category":"page"},{"location":"#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"","category":"page"},{"location":"","page":"Index","title":"Index","text":"Modules = [Titus]","category":"page"},{"location":"#Titus.AA","page":"Index","title":"Titus.AA","text":"AA\n\nType that represents an amino acid\n\nFields\n\naa::Char – single character AA code \nmass::Float32 – mass of an amino acid\n\nExamples\n\nAA(aa::Char) – Inner constructor\n\n\n\n\n\n","category":"type"},{"location":"#Titus.FragmentMatch","page":"Index","title":"Titus.FragmentMatch","text":"FragmentMatch\n\nType that represents a match between a fragment ion and a mass spectrum peak\n\nFields\n\ntransition::Transition – Represents a fragment ion\nintensity::Float32 – Intensity of the matching peak\nmatch_mz::Float32 – M/Z of the matching empirical peak.    NOT the transition mass and may differ from getMZ(transition) by some error\ncount::UInt8 – Number of matches (may want to count the number of matches if the spectrum is researched at    different mass offsets, such as in a cross correlation score)\npeak_int::Int64 – Index of the matching peak in the mass spectrum. \n\nExamples\n\n`FragmentMatch(transition::Transition, intensity::Float32, mass::Float32, count::UInt8, peak_ind::Int64) –    default internal constructor\nFragmentMatch() – constructor for null/empty precursor\n\nGetterMethods\n\ngetMZ(f::FragmentMatch) = getMZ(f.transition)\ngetLow(f::FragmentMatch) = getLow(f.transition)\ngetHigh(f::FragmentMatch) = getHigh(f.transition)\ngetPrecID(f::FragmentMatch) = getPrecID(f.transition)\ngetCharge(f::FragmentMatch) = getCharge(f.transition)\ngetIsotope(f::FragmentMatch) = getIsotope(f.transition)\ngetIonType(f::FragmentMatch) = getIonType(f.transition)\ngetInd(f::FragmentMatch) = getInd(f.transition)\n\n\n\n\n\n","category":"type"},{"location":"#Titus.Ion","page":"Index","title":"Titus.Ion","text":"Ion\n\nAbstract type that represents an ion \n\nTypes that inherit from Ion should implement the following. \n\ngetMZFeature(ion::Ion) = ion.mz\ngetMZ(ion::Ion) = getMZ(getMZFeature(ion))\ngetLow(ion::Ion) = getLow(getMZFeature(ion))\ngetHigh(ion::Ion) = getHigh(getMZFeature(ion))\ngetPrecID(ion::Ion) = ion.prec_id\ngetCharge(ion::Ion) = ion.charge\ngetIsotope(ion::Ion) = ion.isotope\n\n\n\n\n\n","category":"type"},{"location":"#Titus.Mod","page":"Index","title":"Titus.Mod","text":"Mod(mod::String, mods_dict::Dict{String, Float32})\n\nParses a string that is assumed to represent an amino acid and calculates its mass\n\nInput\n\nmod::String: – String representation of a potentially modified amino acid. Constructor enforces formatting. \nmods_dict – Dictionary for named modifications that could appear in mod\n\nOutput\n\nObject of type \"Mod\" with field mass::Float32 that represents the mass of the modification\n\nNotes\n\nAcceptable mod arguments match a regular expression defined in the method There can be three types of modifications. \n\nThere is no modification as in \"K\"\nThe mass is explicitly stated as in \"K[+8.014199]\"\nThe mass is named with a valid key for mods_dict as in \"C[Carb]\".\n\nIn this case mods_dict[\"Carb\"] should return the appropriate mass\n\n\n\n\n\n","category":"type"},{"location":"#Titus.Mod-2","page":"Index","title":"Titus.Mod","text":"MzFeature\n\nType that represents a mass modification\n\nFields\n\nmass:Float32 – mass of the modification\n\nExamples\n\nMod(mass::Float32) – default constructor\n`Mod(mod::String, mods_dict::Dict{String, Float32} = Dict{String, Float32}()) – Constructor \n\nthat parses a string representation of an amino acid to get the mass of any modification of that amino acid`\n\nMod(name::Char) = Mod(0.0) – constructor for unmodified AA\nMod() = Mod(0.0) – constructor for no input\n\n\n\n\n\n","category":"type"},{"location":"#Titus.MzFeature","page":"Index","title":"Titus.MzFeature","text":"MzFeature\n\nType that represents an m/z ratio with a ppm tolerance\n\nFields\n\nmono::Float32 – MZ with upper and lower bounds given a ppm tolerance\nlow::Float32 – Identifier of the precursor ion (parent ion of the fragment/transition)\nhigh::Float32 – Type of transition. For example 'b' for b ion or 'y' for y ion\n\nExamples\n\nMzFeature(mono::Float32; ppm::Float32 = Float32(20)) – default internal constructor\nMzFeature() = MzFeature(Float32(0.0)) – constructor for a default/placeholder MzFeature\n\nGetterMethods\n\ngetMZ(mzfeature::MzFeature) = mzfeature.mono\ngetLow(mzfeature::MzFeature) = mzfeature.low\ngetHigh(mzfeature::MzFeature) = mzfeature.high\n\n\n\n\n\n","category":"type"},{"location":"#Titus.Peptide","page":"Index","title":"Titus.Peptide","text":"Peptide\n\nType that represents a peptide. Minimal describing a peptide of a particular mono-isotopic mass. A Precursor is a Peptide specifying a specific mass and charge.\n\nFields\n\nsequence::String – Sequence of the peptide\npepGroup_id::UInt32 – Identifier of the PeptideGroup to which this Peptide belongs. \nprec_ids::Set{UInt32} – Set of identifiers for Precursors associated with this Peptide\n\nGetterMethods\n\ngetSeq(p::Peptide) = p.sequence\ngetPepGroupID(p::Peptide) = pepGroup_id\ngetPrecIDs(p::Peptide) = p.prec_ids\n\nMethods\n\naddPrecID!(p::Peptide, prec_id::UInt32)\n\nNotes\n\nProtein > PeptideGroup > Peptide > Precursor\n\n\n\n\n\n","category":"type"},{"location":"#Titus.PeptideGroup","page":"Index","title":"Titus.PeptideGroup","text":"PeptideGroup\n\nType that represents an unmodified peptide. Minimal unit specifiable by single-charater amino-acid   symbols alone. Cannot describe modifications. \n\nFields\n\nprot_ids::Set{UInt32} – Set of identifiers for Proteins that contain this Peptide group\npep_ids::Set{UInt32} – Set of identifiers for Peptides contained by this PeptideGroup\nsequence::String – Sequence of the PeptideGroup\n\nExamples\n\nPeptideGroup() = PeptideGroup(Set{UInt32}(), \"\") – constructor for an placeholder \n\nGetterMethods\n\ngetSeq(p::PeptideGroup) = p.sequence\ngetProtIDs(p::PeptideGroup) = p.prot_ids\ngetPepIDs(p::PeptideGroup) = p.pep_ids\n\nMethods\n\naddProtID!(pg::PeptideGroup, prot_id::UInt32)\n\nNotes\n\nProtein > PeptideGroup > Peptide > Precursor\n\n\n\n\n\n","category":"type"},{"location":"#Titus.Precursor","page":"Index","title":"Titus.Precursor","text":"Precursor(residues::Array{Residue, 1}, charge::Int32, isotope::Int32 = Int32(0), prec_id::Int32 = Int32(0), pep_id::Int32 = Int32(0))\n\nConstructor for the Precursor struct. Given a list of amino acid residues, a charge, and an isotope state, makes a precursor object with the correct mz.  (link to Precursor)\n\n\n\n\n\n","category":"type"},{"location":"#Titus.Precursor-2","page":"Index","title":"Titus.Precursor","text":"Precursor <: Ion\n\nType that represents a precursor (A peptide parent ion)\n\nFields\n\nresidues::Vector{Residue} – List of amino acid residues of the precursor in their appropriate order\nmz::MzFeature – MZ with upper and lower bounds given a ppm tolerance\nprec_id::UInt32 – Identifier of the precursor ion (parent ion of the fragment/transition)\ncharge::UInt8 – Charge of the fragment ion\nisotope::UInt8 – Difference in number of neutrons from the monoisotopic fragment \npep_id::UInt32 – Identifier of the peptide from which precursor is derived\n\nExamples\n\nPrecursor(residues::Vector{Residue}, mz::Float32, charge::UInt8,             isotope::UInt8,             pep_id::UInt32,            prec_id::UInt32;             ppm = Float32(20)) – default internal constructor\nPrecursor() – constructor for null/empty precursor\nPrecursor(residues::Vector{Residue}, charge::UInt8,             isotope::UInt8 = UInt8(0),             pep_id::UInt32 = UInt32(0),            prec_id::UInt32 = UInt32(0) – Constructor that calculates mz without having to supply it\nPrecursor(sequence::String; mods_dict::Dict{String, Float32} = Dict{String, Float32}(), charge::UInt8 = UInt8(2),             isotope::UInt8 = UInt8(0),             pep_id::UInt32 = UInt32(0),            prec_id::UInt32 = UInt32(0)) – Constructor that accepts a string representation of a peptide\n\nGetterMethods\n\ngetResidues(precursor::Precursor) = precursor.residues\n\n\n\n\n\n","category":"type"},{"location":"#Titus.Precursor-Tuple{String}","page":"Index","title":"Titus.Precursor","text":"Precursor(sequence::String, mods_dict::Dict{String, Float32}, charge::Int32, isotope::Int32 = Int32(0), prec_id::Int32 = Int32(0), pep_id::Int32 = Int32(0))\n\nAlternate constructor for the Precursor struct. Can accept a string representation of a peptide and a mods_dict  and convert to residues Array{Residue, 1}.  (link to Precusor)\n\n\n\n\n\n","category":"method"},{"location":"#Titus.Precursor-Tuple{}","page":"Index","title":"Titus.Precursor","text":"Precursor()\nConstructor for an \"empty\" or \"default\" precursor\n\n\n\n\n\n","category":"method"},{"location":"#Titus.PrecursorDatabase","page":"Index","title":"Titus.PrecursorDatabase","text":"PrecursorDatabase\n\nData Structure that represents relations between precursors, peptides, peptide groups, and proteins\n\nSuggested Fields\n\nAn implementation of PrecursorTable should have these fields \n\nidtoprot::UnorderedDictionary{UInt32, Protein}– Maps from a protien identifier to a Protein\nprottoid::UnorderedDictionary{String, UInt32} – Maps from a protein name to a protein identifier\nidtopepGroup::UnorderedDictionary{UInt32, PeptideGroup} – Maps a PeptideGroup identifier to a PeptideGroup\npepGrouptoid::UnorderedDictionary{String, UInt32} – Maps a PeptideGroup name/sequence to an identifier\nidtopep::UnorderedDictionary{UInt32, Peptide} – Maps a peptide identifier to a peptide\nidtoprec::Dictionary{UInt32, Precursor} – Precursor has fields pep_id and prec_id. pep_ids are keys for id_to_pep\nsortedprecids::Vector{UInt32} – \nprecidto_transitions::Dictionary{UInt32, Vector{Transition}} –\n\nGetterMethods\n\ngetIDToProt(p::PrecursorDatabase) = p.idtoprot\ngetProtToID(p::PrecursorDatabase) = p.prottoid\ngetIDToPepGroup(p::PrecursorDatabase) = p.idtopepGroup\ngetPepGroupToID(p::PrecursorDatabase) = p.pepGrouptoid\ngetIDToPep(p::PrecursorDatabase) = p.idtopep\ngetIDToPrec(p::PrecursorDatabase) = p.idtoprec\ngetPrecIDToTransitions(p::PrecursorDatabase) = p.precidto_transitions\ngetPrecursorIDs(p::PrecursorDatabase) = p.sortedprecids\ngetProtID(p::PrecursorDatabase, protein::String)\ngetProtID(p::PrecursorDatabase, protein::Protein)\ngetPepGroup(p::PrecursorDatabase, pepGroup_id::UInt32)\ngetPepGroupID(p::PrecursorDatabase, peptide::String)\ngetPepGroupID(p::PrecursorDatabase, pepGroup::PeptideGroup)\ngetPep(p::PrecursorDatabase, pep_id::UInt32)\ngetPrecursor(p::PrecursorDatabase, prec_id::UInt32)\ngetTransitions(p::PrecursorDatabase, prec_id::UInt32)\ngetProtNamesFromPepSeq(p::PrecursorDatabase, peptide::String)\ngetProtNamesFromPepSeq(p::PrecursorDatabase, pepGroup::PeptideGroup)\ngetPepGroupsFromProt(p::PrecursorDatabase, protein::String)\ngetPepSeqsFromProt(p::PrecursorDatabase, protein::String)\ngetPepGroupsFromProt(p::PrecursorDatabase, prot_id::UInt32)\ngetPepSeqsFromProt(p::PrecursorDatabase, prot_id::UInt32)\ngetPepIDFromPrecID(p::PrecursorDatabase, prec_id::UInt32)\n\nMethods\n\ninsertProtID!(p::PrecursorDatabase, protein::String, prot_id::UInt32)\ninsertProt!(p::PrecursorDatabase, protein::String, prot_id::UInt32)\ninsertPepGroupID!(p::PrecursorDatabase, peptide::String, pepGroup_id::UInt32)\ninsertPepGroup!(p::PrecursorDatabase, protein::String, peptide::String, pepGroup_id::UInt32)\nsetSortedPrecursorKeys!(p::PrecursorDatabase)\nprecursorRangeQuery(p::PrecursorDatabase, windowcenter::Float32, leftprecursortolerance::Float32, rightprecursor_tolerance::Float32)\naddProteinToPepGroup!(pd::PrecursorDatabase, protein::String, peptide::String)\naddPepGroupToProtein!(pd::PrecursorDatabase, protein::String, peptide::String)\naddNewProtein!(pd::PrecursorDatabase, protein::String, prot_id::UInt32)\naddNewPeptideGroup!(pd::PrecursorDatabase, peptide::String, pepGroup_id::UInt32, protein::String)\naddPrecursors!(ptable::PrecursorDatabase, charges::Vector{UInt8}, isotopes::Vector{UInt8}, mods_dict::Dict{String, Float32})\naddTransitions!(ptable::PrecursorDatabase, transitioncharges::Vector{UInt8}, transitionisotopes::Vector{UInt8},bstart::Int64,ystart::Int64, fragmentmatchppm::Float32)\n\nNotes\n\nPrecursorDatabase keeps an account of relations between Proteins, PeptideGroups, Peptides, and Precursors. Each Protein, PeptideGroup, Peptide, and Precursor has a unique UInt32 indentifier.  Each also has a string name. See Protein, PeptideGroup, Peptide and Precursor.  Proteins map to one or more PeptideGroups. PeptideGroups map to one or more Peptides,  and each Peptide maps to one or more precursors.\n\n\n\n\n\n","category":"type"},{"location":"#Titus.PrecursorTable","page":"Index","title":"Titus.PrecursorTable","text":"PrecursorTable <: PrecursorDatabase\n\nInherits from PrecursorDatabase. Minimal implementation of methods required for PrecursorDatabase\n\nFields\n\nidtoprot::UnorderedDictionary{UInt32, Protein}– Maps from a protien identifier to a Protein`\nprottoid::UnorderedDictionary{String, UInt32} – Maps from a protein name to a protein identifier\nidtopepGroup::UnorderedDictionary{UInt32, PeptideGroup} – Maps a peptide group identifier to a PeptideGroup`\npepGrouptoid::UnorderedDictionary{String, UInt32} – Maps a PeptideGroup` name/sequence to an identifier\nidtopep::UnorderedDictionary{UInt32, Peptide} – Maps a peptide identifier to a Peptide\nidtoprec::Dictionary{UInt32, Precursor} – Maps a precursor identifier to a Precursor\nsortedprecids::Vector{UInt32} – Precursor ID's for precursors in id_to_prec sorted by m/z \nprecidto_transitions::Dictionary{UInt32, Vector{Transition}} –  Maps a precursor identifier to a Vector{Transition} (fragment ions)\n\nExamples\n\nPrecursorTable() = PrecursorTable(   UnorderedDictionary{UInt32, Protein}(),   UnorderedDictionary{String, UInt32}(),   UnorderedDictionary{UInt32, PeptideGroup}(),   UnorderedDictionary{String, UInt32}(),   UnorderedDictionary{UInt32, Peptide}(),   Vector{Precursor}()) – constructor for a placeholder \n\n\n\n\n\n","category":"type"},{"location":"#Titus.Protein","page":"Index","title":"Titus.Protein","text":"Protein\n\nType that represents a protein. \n\nFields\n\nsequence::String – Sequence of the peptide\npepgroupid::UInt32– Identifier of thes PeptideGroups contained by this Protein\n\nExamples\n\nProtein(name::String) = Protein(name, Set{UInt32}()) – constructor for an placeholder \n\nGetterMethods\n\ngetName(p::Protein) = p.name\ngetPepGroupIDs(p::Protein) = p.pepgroupids\n\nMethods\n\naddPepGroupID!(p::Protein, pepgroupid::UInt32)\n\nNotes\n\nProtein > PeptideGroup > Peptide > Precursor\n\n\n\n\n\n","category":"type"},{"location":"#Titus.Residue","page":"Index","title":"Titus.Residue","text":"Residue\n\nType that represents a (potentially modified) amino acid within a peptide\n\nFields\n\nmass:Float32 – mass of the amino acid\n\nExamples\n\nResidue(aa::AA) – default constructor\nResidue(aa::Char) = Residue(AA(aa))\nResidue(aa::AA, mod::Mod) = Residue(getMass(mod)+getMass(aa))\nResidue(residue::String, mods_dict::Dict{String, Float32}) = Residue(AA(residue[1]), Mod(residue, mods_dict))\nResidue(residue::String) = Residue(residue, Dict{String, Float32}())\nResidue(residue::String, mod_mass::Float32) = Residue(getMass(AA(residue[1])) + mod_mass)\nResidue(residue::Char, mod_mass::Float32) = Residue(getMass(AA(residue)) + mod_mass)\n\nGetter methods\n\ngetMass(residue::Residue) = residue.mass\n\nSee Also\n\ngetResidues(sequence::String,               mods_dict::Dict{String, Float32} = default_mods) – Gets a vector of residues given a string  representation of an amino acid sequence\n\n\n\n\n\n","category":"type"},{"location":"#Titus.Transition","page":"Index","title":"Titus.Transition","text":"Transition <: Ion\n\nType that represents transition (fragment ion of a peptide)\n\nFields\n\nmz::MzFeature – MZ with upper and lower bounds given a ppm tolerance\nprec_id::UInt32 – Identifier of the precursor ion (parent ion of the fragment/transition)\nion_type::Char  – Type of transition. For example 'b' for b ion or 'y' for y ion\nind::UInt8 – Position of fragment ion with reference to parent ion. (A b5+2 ion should have an ind equal to 5)\ncharge::UInt8 – Charge of the fragment ion\nisotope::UInt8 – Difference in number of neutrons from the monoisotopic fragment \n\nExamples\n\nTransition(frag_mz::Float32, prec_id::UInt32, ion_type::Char, ind::UInt8,              charge::UInt8,              isotope::UInt8;              ppm = Float32(20)) – default internal constructor\nTransition(residues::Vector{Residue}; ion_type::Char = 'y', charge::UInt8 = UInt8(1),              ind::UInt8 = UInt8(length(residues)),              isotope::UInt8 = UInt8(0),              prec_id::UInt32 = UInt32(0)) – constructor that calculates the appropriate mz\n\nGetterMethods\n\ngetIonType(transition::Transition) = transition.ion_type\ngetInd(transition::Transition) = transition.ind\n\n\n\n\n\n","category":"type"},{"location":"#Titus.Transition-Tuple{Vector{Residue}}","page":"Index","title":"Titus.Transition","text":"Transition(residues::Vector{Residue}; ion_type::Char = 'y', charge::UInt8 = UInt8(1), ind::UInt8 = UInt8(length(residues)), isotope::UInt8 = UInt8(0), prec_id::UInt32 = UInt32(0))\n\nConstructor for the `Transition` struct. Given a list of amino acid residues, ion type (b or y), charge state, and isotopic state makes a transition with the correct mz.\n\n\n\n\n\n","category":"method"},{"location":"#Titus.addPepGroup!-Tuple{PrecursorDatabase, String, UInt32, Set{UInt32}, String}","page":"Index","title":"Titus.addPepGroup!","text":"addNewPeptideGroup!(pd::PrecursorDatabase, peptide::String, pepGroup_id::UInt32, protein::String)\n\nCreate a new PeptideGroup and peptide group id and add them to the lookup tables\n\n\n\n\n\n","category":"method"},{"location":"#Titus.addPepGroupToProtein!-Tuple{PrecursorDatabase, UInt32, UInt32}","page":"Index","title":"Titus.addPepGroupToProtein!","text":"addPepGroupToProtein!(pd::PrecursorDatabase, protein::String, peptide::String)\n\nFor the protein to which the peptide belongs, add the correct peptide group id to its pep_group_ids\n\n\n\n\n\n","category":"method"},{"location":"#Titus.addPrecursors!-Tuple{PrecursorDatabase, Vector{UInt8}, Vector{UInt8}, Dict{String, Float32}}","page":"Index","title":"Titus.addPrecursors!","text":"addPrecursors!(ptable::PrecursorTable, charges::Vector{UInt8}, isotopes::Vector{UInt8}, mods_dict::Dict{String, Float32})\n\nModifies a PrecursorDatabase to fill the precursors field. Gets a Precursor for each unique Peptide in ptable. Sorts the  precursors in order of increasing mz.   \n\nInput\n\nptable::PrecursorTable – See PrecursorTable\ncharges::Vector{UInt8} – Get a precursor with these charges for each Peptide in ptable\nisotopes::Vector{UInt8} – Get a precursor with these isotopes for each Peptide in ptable\nmods_dict::Dict{String, Float32} – Dict mapping modifications to their masses\n\nOutput\n\nFills the id_to_prec and sorted_prec_ids fields in a PrecursorDatabase \n\nExamples\n\ntestmods::Dict{String, Float32} =  Dict{String, Float32}(     \"Carb\" => Float32(57.021464),     \"Harg\" => Float32(10),     \"Hlys\" => Float32(8), ) fixedmods = [(p=r\"C\", r=\"C[Carb]\")] var_mods = [(p=r\"(K) r=Hlys) (p=r(R)\", r=\"[Harg]\")]\n\ntestPtable = PrecursorTable() buildPrecursorTable!(testPtable, fixedmods, varmods, 2, \"../data/peptidelists/PROTPEPTIDETEST1.txt\") getPrecursors!(testPtable, UInt8[2, 3, 4], UInt8[0], testmods)\n\n\n\n\n\n","category":"method"},{"location":"#Titus.addProtein!-Tuple{PrecursorDatabase, String, UInt32}","page":"Index","title":"Titus.addProtein!","text":"addNewProtein!(pd::PrecursorDatabase, protein::String, prot_id::UInt32)\n\nCreate a new Protein and protein id and add them to the lookup tables\n\n\n\n\n\n","category":"method"},{"location":"#Titus.addProteinToPepGroup!-Tuple{PrecursorDatabase, UInt32, UInt32}","page":"Index","title":"Titus.addProteinToPepGroup!","text":"addProteinToPepGroup!(pd::PrecursorDatabase, protein::String, peptide::String)\n\nFor the PeptideGroup to which \"peptide\" belongs, add the protein to its prot_ids\n\n\n\n\n\n","category":"method"},{"location":"#Titus.addTransitions!-Tuple{PrecursorDatabase, Vector{UInt8}, Vector{UInt8}, Int64, Int64, Float32}","page":"Index","title":"Titus.addTransitions!","text":"addTransitions!(ptable::PrecursorDatabase, transition_charges::Vector{UInt8}, transition_isotopes::Vector{UInt8},b_start::Int64,y_start::Int64, fragment_match_ppm::Float32)\n\nModifies a PrecursorDatabase to add Transitions to the 'precidtotransitions' field corresponding to all Precursors  in the `idto_prec` field. Gets all transitions  for the specified charge and isotopic states for all precursors in the PrecursorDatabase. \n\nInput\n\nptable::PrecursorTable – See PrecursorTable\ntransition_charges::Vector{UInt8} – Get Transitions with these charges for each Precursor in ptable\ntransition_isotopes::Vector{UInt8} – Get Transitions with these isotopes for each Precursorinptable`\nb_start::Int64 – Get transitions bn+x and higher. At 3 would exclude b2 and b1 ions\ny_start::Int64 – Same as b_start but for y ions\nfragment_match_ppm::Float32 – Fragment match tolerance for the precursors\n\nOutput\n\nFills the prec_id_to_transitions field in a PrecursorDatabase \n\nExamples\n\n\n\n\n\n","category":"method"},{"location":"#Titus.getBIonModifier-Tuple{UInt8}","page":"Index","title":"Titus.getBIonModifier","text":"getBIonModifier(charge::UInt8)\n\nMass modification that needs to be added to b-ions\n\n\n\n\n\n","category":"method"},{"location":"#Titus.getFragIons-Tuple{Vector{Residue}}","page":"Index","title":"Titus.getFragIons","text":"getFragIons(residues::Vector{Residue}; charge::UInt8 = UInt8(1), isotope::UInt8 = UInt8(0), y_start::Int = 3, b_start::Int = 3)\n\nUses calls to getIonSeries to concatenate both the b and y ion series together in a single Vector{Float32}\n\nInput\n\nresidues::Vector{Residue}: – List of amino acid residues in the peptide ion\ncharge::UInt8 – Charge of the fragment ions\nb_start::Int=3  – Index of first ion the the b-ion series to compute. \ny_start::Int=3  – Index of first ion the the y-ion series to compute. \nisotope::UInt8=UInt8(0) – Diference in the number of isotopes from the monoisotopic ion. \n\nOutput\n\nA Vector{Float32} wich each m/z in the ion series\n\nNotes\n\nThe modifier argument ought to depend on the kind of ion. For a 'b' ion series PROTON*charge is appropriate,\n\nbut for a 'y' ion series, PROTON*charge + H2O would be appropriate. \n\nWill not allow the index of the ion to be equal to or less than the charge. For example,\n\nb2+2 ions could only be calculated in error and are therefore excluded even if start  is set to 2. \n\nIf start exceeds length(residues)-1, then only the N-1 ion is calculated, that is,\n\nthe highest mass ion in the series. \n\nExamples\n\n#Gets the b3+1-b6+1 and y3+1-y6+1 ions\n\njulia> getFragIons(reverse(getResidues(\"PEPTIDE\")), b_start = 3, y_start = 3)\n8-element Vector{Float32}:\n 358.16083\n 459.2085\n 556.2612\n 685.30383\n 342.16595\n 443.21365\n 556.29767\n 671.3246\n\nSee Also\n\nAlternate convience methods\n\ngetFragIons(residues::Vector{Residue}; charge::UInt8 = UInt8(1),             isotope::UInt8 = UInt8(0),              y_start::Int = 3,              b_start::Int = 3) - Default method\ngetFragIons(precursor::Precursor; charge::UInt8 = UInt8(1),              isotope::UInt8 = UInt8(0),              y_start::Int = 3,              b_start::Int = 3) - Can supply a Precursor rather than a  Vector{Residues} input\ngetFragIons(precursor::Precursor,charges::Vector{UInt8},              isotopes::Vector{UInt8};              y_start::Int = 3,              b_start::Int = 3) - Gets b and y ion seriers for multiple charge and isotopic states\n\n\n\n\n\n","category":"method"},{"location":"#Titus.getIonMZ-Tuple{Vector{Residue}, Char, UInt8}","page":"Index","title":"Titus.getIonMZ","text":"getIonMZ(residues::Vector{Residue}, ion_type::Char, charge::UInt8; isotope::UInt8 = UInt8(0))\n\nAlternate getIonMZ method that chooses the correct mass modifier for 'b', 'y', and 'p' ions respectively. \n\nInput\n\n- `residues::Vector{Residue}`: -- List of amino acid residues in the peptide ion\n- `ion_type::Char` -- Type of fragment ion. Currently supports, 'b', 'y', and 'p'. \n- `charge::UInt8` -- Charge of the ion\n- `isotope::UInt8=UInt8(0)` -- Diference in the number of isotopes from the monoisotopic ion.\n\nNotes\n\nSee main method\n    getIonMZ(residues::Vector{Residue}, charge::UInt8; modifier::Float32 = PROTON*charge + H2O, isotope::UInt8 = UInt8(0))\nfor more details\n\n\n\n\n\n","category":"method"},{"location":"#Titus.getIonMZ-Tuple{Vector{Residue}, UInt8}","page":"Index","title":"Titus.getIonMZ","text":"getIonMZ(residues::Vector{Residue}, charge::UInt8; modifier::Float32 = PROTON*charge + H2O, isotope::UInt8 = UInt8(0))::Float32\n\nGet the mz ratio of an ion\n\nInput\n\nresidues::Vector{Residue}: – List of amino acid residues in the peptide ion\ncharge::UInt8 – Charge of the ion\nmodifier::Float32=PROTON*charge + H2O – Added to the mass of the ion\nisotope::UInt8=UInt8(0) – Diference in the number of isotopes from the monoisotopic ion. \n\nOutput\n\nA Float32 representing the mass-to-charge ratio (m/z) of an ion\n\nNotes\n\nThe modifier argument ought to depend on the kind of ion. For B ions PROTONcharge is appropriate, but for 'y' or precursor ions, PROTONcharge + H2O would be appropriate.\n\nAlgorithm\n\nSum the amino acid residue masses, add modifier + isotope*NEUTRON and then divide the total by the charge. \n\nExamples\n\n#Gets the b6+1 ion MZ\n\njulia> getIonMZ(getResidues(\"PEPTIDE\")[1:6], UInt8(1), modifier = PROTON)\n653.314f0\n\n#Gets the y6+1 ion MZ\n\njulia> getIonMZ(reverse(getResidues(\"PEPTIDE\"))[1:6], UInt8(1))\n703.3144f0\n\n\n\n\n\n","category":"method"},{"location":"#Titus.getIonSeries-Tuple{Vector{Residue}, UInt8}","page":"Index","title":"Titus.getIonSeries","text":"getIonSeries(residues::Vector{Residue}, charge::UInt8; start::Int = 3, modifier::Float32 = PROTON*charge + H2O, isotope::UInt8 = UInt8(0))\n\nGets the m/z's for an ion series as a Vector{Float32}. \n\nInput\n\nresidues::Vector{Residue}: – List of amino acid residues in the peptide ion\ncharge::UInt8 – Charge of the fragment ions\nstart::Int=3  – Index of first ion the the series to compute.\nisotope::UInt8=UInt8(0) – Diference in the number of isotopes from the monoisotopic ion. \n\nOutput\n\nA Vector{Float32} wich each m/z in the ion series\n\nNotes\n\nThe modifier argument ought to depend on the kind of ion. For a 'b' ion series PROTON*charge is appropriate,\n\nbut for a 'y' ion series, PROTON*charge + H2O would be appropriate. \n\nWill not allow the index of the ion to be equal to or less than the charge. For example,\n\nb2+2 ions could only be calculated in error and are therefore excluded even if start  is set to 2. \n\nIf start exceeds length(residues)-1, then only the N-1 ion is calculated, that is,\n\nthe highest mass ion in the series. \n\nExamples\n\n#Gets the y3+2 through y6+2 ions\n\njulia> getIonSeries(reverse(getResidues(\"PEPTIDE\")), UInt8(2), start = 3)\n4-element view(::Vector{Float32}, 3:6) with eltype Float32:\n 188.58934\n 239.11317\n 287.63956\n 352.16086\n\n#Gets the b4+2 through b6+2 ions\n\njulia> getIonSeries(getResidues(\"PEPTIDE\"), UInt8(2), start = 4, modifier = PROTON*UInt8(2))\n3-element view(::Vector{Float32}, 4:6) with eltype Float32:\n 213.10518\n 269.6472\n 327.16064\n\n\n\n\n\n","category":"method"},{"location":"#Titus.getNearest-Tuple{Transition, Vector{Union{Missing, Float32}}, Int64}","page":"Index","title":"Titus.getNearest","text":"getNearest(transition::Transition, masses::Vector{Union{Missing, Float32}}, peak::Int; δ = 0.01)\n\nFinds the peak (index of masses) nearest in mass to the transition but still within the tolerance (getLow(transition)<masses[peak]<getHigh(transition)).  Starts searching at initially supplied peak and increases the index until outside the tolerance. There could be multiple peaks within the tolerance,  and this function selects the one with the lowest mass error to the fragment ion. \n\nInput\n\ntransition::Transition: – Represents a fragment ion\nmasses::Vector{Union{Missing, Float32}} – Mass list from a centroided mass spectrum. MUST BE SORTED IN ASCENDING ORDER. \npeak::Int – An index for a mass in masses\nδ – A mass offset that can be applied to each mass in masses \n\nOutput\n\nAn Int representing the index of the m/z in masses nearest in m/z to that of the fragment m/z. \n\nNotes\n\nIt is assumed that masses is sorted in ascending order. \nIn practice, when called from matchPeaks!, masses[peak] will already be within the fragment m/z tolerance.\n\nUsually there will not be another peak in masses where this is true, but it is possible for multiple peaks to  fall within the tolerance. The purpose of this function is to select the best peak (closes in mass) when this happens.  \n\nAlgorithm\n\nExamples\n\n\n\n\n\n","category":"method"},{"location":"#Titus.getPrecursors-Tuple{Vector{Residue}}","page":"Index","title":"Titus.getPrecursors","text":"getPrecursors(residues::Vector{Residue}; charges::Vector{UInt8} = UInt8[1,2],isotopes::Vector{UInt8}=UInt8[0],pep_id::UInt32=UInt32(0)) \n\nAlternate constructor for the Precursor struct that Can accept a string representation of a peptide\n\nInput\n\nOutput\n\nNotes\n\n(link to getResidues())\n\n\n\n\n\n","category":"method"},{"location":"#Titus.getYIonModifier-Tuple{UInt8}","page":"Index","title":"Titus.getYIonModifier","text":"getYIonModifier(charge::UInt8)\n\nMass modification that needs to be added to y-ions\n\n\n\n\n\n","category":"method"},{"location":"#Titus.matchPeaks!-Tuple{Vector{FragmentMatch}, Vector{Transition}, Vector{Union{Missing, Float32}}, Vector{Union{Missing, Float32}}, Float64, UInt32, UInt32}","page":"Index","title":"Titus.matchPeaks!","text":"function matchPeaks!(matches::Vector{FragmentMatch}, Transitions::Vector{Transition}, masses::Vector{Union{Missing, Float32}}, intensities::Vector{Union{Missing, Float32}}, δ::Float64)\n\nFinds the best matching peak in a mass spectrum for each transition/fragment ion supplied if the match is within the fragment tolerance.      Adds each FragmentMatch to matches if not already present. Otherwise,      modifies an existing match (see setFragmentMatch!).\n\nInput\n\nmatches::Vector{FragmentMatch}: – A list representing fragment ions that match peaks in the mass spectrum (masses)\nTransitions::Vector{Transition – A list of fragment ions to search for in the spectrum (masses). MUST BE SORTED IN ASCENDING ORDER BY getMZ(transition)\nmasses::Vector{Union{Missing, Float32}} – Mass list from a centroided mass spectrum. MUST BE SORTED IN ASCENDING ORDER.\nintensities::Vector{Union{Missing, Float32}} – The intensity list from a centroided mass spectrum. Must be the same length as masses\nδ::Float64 – A mass offset that can be applied to each mass in masses\n\nOutput\n\nModifies matches[match] if match is <= lenth(matches). Otherwise adds a new FragmentMatch at matches[match]\n\nNotes\n\nUpdating a match in matches could be useful if researching the same spectra many times at different mass offsets with matchPeaks!    This could be done to calculate a cross correlatoin score for example. If a spectrum is only searched once, then matches should   only be added to matches and existing ones never modified. \nThe fragment tolerance is specified by each Transition. A Transition<:Ion has a field mz::MzFeature which specifies the monoisotopic mass   and also upper and lower bounds (the tolerance). See getLow(ion::Ion) and getHigh(ion::Ion). This is why the user need not supply a fragment tolerance to matchPeaks! \nmasses and intensities contain type unions Union{Missing, Float32}. This method does nothing to check for Missing values, and indeed,   it is assumed that there are none, and the presence of any Missing values will cause an error. The reason for the type union is an idiosyncracy   of the Arrow.jl package and how it implements nested data types in Arrow files. \n\nAlgorithm\n\nGiven a list of fragment ions and a centroided mass spectrum both sorted by m/z, it is efficient to search the spetrum for matches in a \"single pass\" through the spectrum. If there are T transitions and P peaks should be O(T+P). If there are multiple peaks within the tolerance for a given  fragment ion, the peak closest in m/z to the fragment ion is chosen. It is possible to assign the same peak to multiple fragment ions, but  each fragment ion is only assigned to 0 or 1 peaks. \n\nExamples\n\n\n\n\n\n","category":"method"},{"location":"#Titus.matchPeaks-Tuple{Vector{Transition}, Vector{Union{Missing, Float32}}, Vector{Union{Missing, Float32}}}","page":"Index","title":"Titus.matchPeaks","text":"function matchPeaks!(matches::Vector{FragmentMatch}, Transitions::Vector{Transition}, masses::Vector{Union{Missing, Float32}}, intensities::Vector{Union{Missing, Float32}}, δ::Float64)\n\nA wrapper for calling matchPeaks at different to search spectra at a list of mass offset.      Each all to matchPeaks Finds the best matching peak in a mass spectrum for each transition/fragment ion supplied if the match is within the fragment tolerance.      Adds each FragmentMatch to matches if not already present. Otherwise, modifies an existing match (see setFragmentMatch!). (see matchPeaks for additional details)\n\nInput\n\nmatches::Vector{FragmentMatch}: – A list representing fragment ions that match peaks in the mass spectrum (masses)\nTransitions::Vector{Transition – A list of fragment ions to search for in the spectrum (masses). MUST BE SORTED IN ASCENDING ORDER BY getMZ(transition)\nmasses::Vector{Union{Missing, Float32}} – Mass list from a centroided mass spectrum. MUST BE SORTED IN ASCENDING ORDER.\nintensities::Vector{Union{Missing, Float32}} – The intensity list from a centroided mass spectrum. Must be the same length as masses\nδ::Float64 – A mass offset that can be applied to each mass in masses\n\nOutput\n\nModifies matches[match] if match is <= lenth(matches). Otherwise adds a new FragmentMatch at matches[match]\n\nNotes\n\nSearching a mass spectrum many times at different mass offsets could be useful for caculating cross correlation scores. \n\nAlgorithm\n\nSee `matchPeaks`\n\nExamples\n\n\n\n\n\n","category":"method"},{"location":"#Titus.precursorRangeQuery-Tuple{PrecursorDatabase, Float32, Float32, Float32}","page":"Index","title":"Titus.precursorRangeQuery","text":"precursorRangeQuery(p::PrecursorDatabase, window_center::Float32, left_precursor_tolerance::Float32, right_precursor_tolerance::Float32)\n\nFinds precursor IDs mapping to Precursors with m/z ratios in the tolerance specified by window_center, left_precursor_tolerance, and right_precursor_tolerance Assumes the p.idtoprec dictionary is already sorted. see setSortedPrecursorKeys!\n\n\n\n\n\n","category":"method"},{"location":"#Titus.setFragmentMatch!-Tuple{Vector{FragmentMatch}, Int64, Transition, Float32, Float32, Int64, UInt32, UInt32}","page":"Index","title":"Titus.setFragmentMatch!","text":"setFragmentMatch!(matches::Vector{FragmentMatch}, match::Int, transition::Transition, mass::Float32, intensity::Float32, peak_ind::Int64)\n\nAdds a FragmentMatch to matches if match is not an index in matches, otherwise, updates the match.\n\nInput\n\nhits::Vector{FragmentMatch}: – Represents a fragment ion\nmatch::Int – Index of the match. Must be <=N+1 where N is length(hits) \nmass::Float32 – m/z of the emperical peak matched to the transition\nintensity::Float32 – intensity of the emperical peak matched to the transition\npeak_ind – unique index of the emperical peak matched to the transition\n\nOutput\n\nModifies matches[match] if match is <= lenth(matches). Otherwise adds a new FragmentMatch at matches[match]\n\nNotes\n\nUpdating a match in matches could be useful if researching the same spectra many times at different mass offsets with matchPeaks!    This could be done to calculate a cross correlatoin score for example. If a spectrum is only searched once, then matches should   only be added to matches and existing ones never modified. \nRecording the peak_ind could be useful, for example, \"chimeric\" scoring of a spectrum from a Vector{FragmentMatch} type. The best scoring precursor would   have fragments matching to known peak_ind. The Vector{FragmentMatch} could be rescored but excluding FragmentMatches corresponding   to those peak_ind's. This would enable a simple chimeric spectra scoring that would not involve completely researching the spectrum (making an additional call to matchPeaks). \n\nAlgorithm\n\nExamples\n\n\n\n\n\n","category":"method"},{"location":"#Titus.setSortedPrecursorKeys!-Tuple{PrecursorDatabase}","page":"Index","title":"Titus.setSortedPrecursorKeys!","text":"setSortedPrecursorKeys!(p::PrecursorDatabase)\n\nSorts precursors in the PrecursorDatabase by their m/z ratio. First sorts the Dictionary{UInt32, Precursor} p.id_to_prec that maps precursor id's to Precursors. Sets p.sorted_prec_ids as a vector of the ID's for these precursors (sorted). \n\n\n\n\n\n","category":"method"}]
}
