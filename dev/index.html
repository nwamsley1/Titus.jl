<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index · Titus.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://nwamsley1.github.io/Titus.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="README/">Titus.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="README/">Introduction</a></li><li><a class="tocitem" href="gettingstarted/">-</a></li><li><span class="tocitem">User&#39;s guide</span><ul><li><a class="tocitem" href="interface/">-</a></li></ul></li><li><span class="tocitem">Developer&#39;s guide</span><ul><li><a class="tocitem" href="wrappers/">-</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/test/">-</a></li></ul></li><li class="is-active"><a class="tocitem" href>Index</a></li><li><a class="tocitem" href="license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nwamsley1/Titus.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><ul><li><a href="#Titus.AA"><code>Titus.AA</code></a></li><li><a href="#Titus.FragmentMatch"><code>Titus.FragmentMatch</code></a></li><li><a href="#Titus.Ion"><code>Titus.Ion</code></a></li><li><a href="#Titus.Mod"><code>Titus.Mod</code></a></li><li><a href="#Titus.Mod"><code>Titus.Mod</code></a></li><li><a href="#Titus.MzFeature"><code>Titus.MzFeature</code></a></li><li><a href="#Titus.Peptide"><code>Titus.Peptide</code></a></li><li><a href="#Titus.PeptideGroup"><code>Titus.PeptideGroup</code></a></li><li><a href="#Titus.Precursor"><code>Titus.Precursor</code></a></li><li><a href="#Titus.Precursor-Tuple{String}"><code>Titus.Precursor</code></a></li><li><a href="#Titus.Precursor-Tuple{}"><code>Titus.Precursor</code></a></li><li><a href="#Titus.Precursor"><code>Titus.Precursor</code></a></li><li><a href="#Titus.PrecursorDatabase"><code>Titus.PrecursorDatabase</code></a></li><li><a href="#Titus.PrecursorTable"><code>Titus.PrecursorTable</code></a></li><li><a href="#Titus.Protein"><code>Titus.Protein</code></a></li><li><a href="#Titus.Residue"><code>Titus.Residue</code></a></li><li><a href="#Titus.Transition-Tuple{Vector{Residue}}"><code>Titus.Transition</code></a></li><li><a href="#Titus.Transition"><code>Titus.Transition</code></a></li><li><a href="#Titus.addPepGroup!-Tuple{PrecursorDatabase, String, UInt32, Set{UInt32}, String}"><code>Titus.addPepGroup!</code></a></li><li><a href="#Titus.addPepGroupToProtein!-Tuple{PrecursorDatabase, UInt32, UInt32}"><code>Titus.addPepGroupToProtein!</code></a></li><li><a href="#Titus.addPrecursors!-Tuple{PrecursorDatabase, Vector{UInt8}, Vector{UInt8}, Dict{String, Float32}}"><code>Titus.addPrecursors!</code></a></li><li><a href="#Titus.addProtein!-Tuple{PrecursorDatabase, String, UInt32}"><code>Titus.addProtein!</code></a></li><li><a href="#Titus.addProteinToPepGroup!-Tuple{PrecursorDatabase, UInt32, UInt32}"><code>Titus.addProteinToPepGroup!</code></a></li><li><a href="#Titus.addTransitions!-Tuple{PrecursorDatabase, Vector{UInt8}, Vector{UInt8}, Int64, Int64, Float32}"><code>Titus.addTransitions!</code></a></li><li><a href="#Titus.getBIonModifier-Tuple{UInt8}"><code>Titus.getBIonModifier</code></a></li><li><a href="#Titus.getFragIons-Tuple{Vector{Residue}}"><code>Titus.getFragIons</code></a></li><li><a href="#Titus.getIonMZ-Tuple{Vector{Residue}, UInt8}"><code>Titus.getIonMZ</code></a></li><li><a href="#Titus.getIonMZ-Tuple{Vector{Residue}, Char, UInt8}"><code>Titus.getIonMZ</code></a></li><li><a href="#Titus.getIonSeries-Tuple{Vector{Residue}, UInt8}"><code>Titus.getIonSeries</code></a></li><li><a href="#Titus.getNearest-Tuple{Transition, Vector{Union{Missing, Float32}}, Int64}"><code>Titus.getNearest</code></a></li><li><a href="#Titus.getPrecursors-Tuple{Vector{Residue}}"><code>Titus.getPrecursors</code></a></li><li><a href="#Titus.getYIonModifier-Tuple{UInt8}"><code>Titus.getYIonModifier</code></a></li><li><a href="#Titus.matchPeaks-Tuple{Vector{Transition}, Vector{Union{Missing, Float32}}, Vector{Union{Missing, Float32}}}"><code>Titus.matchPeaks</code></a></li><li><a href="#Titus.matchPeaks!-Tuple{Vector{FragmentMatch}, Vector{Transition}, Vector{Union{Missing, Float32}}, Vector{Union{Missing, Float32}}, Float64, UInt32, UInt32}"><code>Titus.matchPeaks!</code></a></li><li><a href="#Titus.precursorRangeQuery-Tuple{PrecursorDatabase, Float32, Float32, Float32}"><code>Titus.precursorRangeQuery</code></a></li><li><a href="#Titus.setFragmentMatch!-Tuple{Vector{FragmentMatch}, Int64, Transition, Float32, Float32, Int64, UInt32, UInt32}"><code>Titus.setFragmentMatch!</code></a></li><li><a href="#Titus.setSortedPrecursorKeys!-Tuple{PrecursorDatabase}"><code>Titus.setSortedPrecursorKeys!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Titus.AA" href="#Titus.AA"><code>Titus.AA</code></a> — <span class="docstring-category">Type</span></header><section><div><p>AA</p><p>Type that represents an amino acid</p><p><strong>Fields</strong></p><ul><li>aa::Char – single character AA code </li><li>mass::Float32 – mass of an amino acid</li></ul><p><strong>Examples</strong></p><ul><li><code>AA(aa::Char)</code> – Inner constructor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/precursor.jl#L14-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.FragmentMatch" href="#Titus.FragmentMatch"><code>Titus.FragmentMatch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FragmentMatch</code></pre><p>Type that represents a match between a fragment ion and a mass spectrum peak</p><p><strong>Fields</strong></p><ul><li>transition::Transition – Represents a fragment ion</li><li>intensity::Float32 – Intensity of the matching peak</li><li>match_mz::Float32 – M/Z of the matching empirical peak.    NOT the transition mass and may differ from getMZ(transition) by some error</li><li>count::UInt8 – Number of matches (may want to count the number of matches if the spectrum is researched at    different mass offsets, such as in a cross correlation score)</li><li>peak_int::Int64 – Index of the matching peak in the mass spectrum. </li></ul><p><strong>Examples</strong></p><ul><li>`FragmentMatch(transition::Transition, intensity::Float32, mass::Float32, count::UInt8, peak_ind::Int64) –    default internal constructor</li><li><code>FragmentMatch()</code> – constructor for null/empty precursor</li></ul><p><strong>GetterMethods</strong></p><ul><li>getMZ(f::FragmentMatch) = getMZ(f.transition)</li><li>getLow(f::FragmentMatch) = getLow(f.transition)</li><li>getHigh(f::FragmentMatch) = getHigh(f.transition)</li><li>getPrecID(f::FragmentMatch) = getPrecID(f.transition)</li><li>getCharge(f::FragmentMatch) = getCharge(f.transition)</li><li>getIsotope(f::FragmentMatch) = getIsotope(f.transition)</li><li>getIonType(f::FragmentMatch) = getIonType(f.transition)</li><li>getInd(f::FragmentMatch) = getInd(f.transition)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/matchpeaks.jl#L3-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Ion" href="#Titus.Ion"><code>Titus.Ion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Ion</code></pre><p>Abstract type that represents an ion </p><p>Types that inherit from <code>Ion</code> should implement the following. </p><ul><li>getMZFeature(ion::Ion) = ion.mz</li><li>getMZ(ion::Ion) = getMZ(getMZFeature(ion))</li><li>getLow(ion::Ion) = getLow(getMZFeature(ion))</li><li>getHigh(ion::Ion) = getHigh(getMZFeature(ion))</li><li>getPrecID(ion::Ion) = ion.prec_id</li><li>getCharge(ion::Ion) = ion.charge</li><li>getIsotope(ion::Ion) = ion.isotope</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/precursor.jl#L257-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Mod" href="#Titus.Mod"><code>Titus.Mod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Mod(mod::String, mods_dict::Dict{String, Float32})</code></pre><p>Parses a string that is assumed to represent an amino acid and calculates its mass</p><p><strong>Input</strong></p><ul><li><code>mod::String</code>: – String representation of a potentially modified amino acid. Constructor enforces formatting. </li><li><code>mods_dict</code> – Dictionary for named modifications that could appear in <code>mod</code></li></ul><p><strong>Output</strong></p><p>Object of type &quot;Mod&quot; with field mass::Float32 that represents the mass of the modification</p><p><strong>Notes</strong></p><p>Acceptable <code>mod</code> arguments match a regular expression defined in the method There can be three types of modifications. </p><ul><li><ol><li>There is no modification as in &quot;K&quot;</li></ol></li><li><ol><li>The mass is explicitly stated as in &quot;K[+8.014199]&quot;</li></ol></li><li><ol><li>The mass is named with a valid key for <code>mods_dict</code> as in &quot;C[Carb]&quot;.</li></ol></li></ul><p>In this case mods_dict[&quot;Carb&quot;] should return the appropriate mass</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/precursor.jl#L98-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Mod" href="#Titus.Mod"><code>Titus.Mod</code></a> — <span class="docstring-category">Type</span></header><section><div><p>MzFeature</p><p>Type that represents a mass modification</p><p><strong>Fields</strong></p><ul><li>mass:Float32 – mass of the modification</li></ul><p><strong>Examples</strong></p><ul><li><code>Mod(mass::Float32)</code> – default constructor</li><li>`Mod(mod::String, mods_dict::Dict{String, Float32} = Dict{String, Float32}()) – Constructor </li></ul><p>that parses a string representation of an amino acid to get the mass of any modification of that amino acid`</p><ul><li><code>Mod(name::Char) = Mod(0.0)</code> – constructor for unmodified AA</li><li><code>Mod() = Mod(0.0)</code> – constructor for no input</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/precursor.jl#L76-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.MzFeature" href="#Titus.MzFeature"><code>Titus.MzFeature</code></a> — <span class="docstring-category">Type</span></header><section><div><p>MzFeature</p><p>Type that represents an m/z ratio with a ppm tolerance</p><p><strong>Fields</strong></p><ul><li>mono::Float32 – MZ with upper and lower bounds given a ppm tolerance</li><li>low::Float32 – Identifier of the precursor ion (parent ion of the fragment/transition)</li><li>high::Float32 – Type of transition. For example &#39;b&#39; for b ion or &#39;y&#39; for y ion</li></ul><p><strong>Examples</strong></p><ul><li><code>MzFeature(mono::Float32; ppm::Float32 = Float32(20))</code> – default internal constructor</li><li><code>MzFeature() = MzFeature(Float32(0.0))</code> – constructor for a default/placeholder MzFeature</li></ul><p><strong>GetterMethods</strong></p><ul><li>getMZ(mz<em>feature::MzFeature) = mz</em>feature.mono</li><li>getLow(mz<em>feature::MzFeature) = mz</em>feature.low</li><li>getHigh(mz<em>feature::MzFeature) = mz</em>feature.high</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/precursor.jl#L220-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Peptide" href="#Titus.Peptide"><code>Titus.Peptide</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Peptide</code></pre><p>Type that represents a peptide. Minimal describing a peptide of a particular mono-isotopic mass. A <code>Precursor</code> is a <code>Peptide</code> specifying a specific mass and charge.</p><p><strong>Fields</strong></p><ul><li>sequence::String – Sequence of the peptide</li><li>pepGroup_id::UInt32 – Identifier of the <code>PeptideGroup</code> to which this <code>Peptide</code> belongs. </li><li>prec_ids::Set{UInt32} – Set of identifiers for <code>Precursor</code>s associated with this <code>Peptide</code></li></ul><p><strong>GetterMethods</strong></p><ul><li>getSeq(p::Peptide) = p.sequence</li><li>getPepGroupID(p::Peptide) = pepGroup_id</li><li>getPrecIDs(p::Peptide) = p.prec_ids</li></ul><p><strong>Methods</strong></p><ul><li>addPrecID!(p::Peptide, prec_id::UInt32)</li></ul><p><strong>Notes</strong></p><p>Protein &gt; PeptideGroup &gt; Peptide &gt; Precursor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/getPrecursors.jl#L51-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.PeptideGroup" href="#Titus.PeptideGroup"><code>Titus.PeptideGroup</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PeptideGroup</code></pre><p>Type that represents an unmodified peptide. Minimal unit specifiable by single-charater amino-acid   symbols alone. Cannot describe modifications. </p><p><strong>Fields</strong></p><ul><li>prot_ids::Set{UInt32} – Set of identifiers for <code>Protein</code>s that contain this <code>Peptide</code> group</li><li>pep_ids::Set{UInt32} – Set of identifiers for <code>Peptide</code>s contained by this <code>PeptideGroup</code></li><li>sequence::String – Sequence of the <code>PeptideGroup</code></li></ul><p><strong>Examples</strong></p><ul><li><code>PeptideGroup() = PeptideGroup(Set{UInt32}(), &quot;&quot;)</code> – constructor for an placeholder </li></ul><p><strong>GetterMethods</strong></p><ul><li>getSeq(p::PeptideGroup) = p.sequence</li><li>getProtIDs(p::PeptideGroup) = p.prot_ids</li><li>getPepIDs(p::PeptideGroup) = p.pep_ids</li></ul><p><strong>Methods</strong></p><ul><li>addProtID!(pg::PeptideGroup, prot_id::UInt32)</li></ul><p><strong>Notes</strong></p><p>Protein &gt; PeptideGroup &gt; Peptide &gt; Precursor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/getPrecursors.jl#L5-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Precursor" href="#Titus.Precursor"><code>Titus.Precursor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Precursor(residues::Array{Residue, 1}, charge::Int32, isotope::Int32 = Int32(0), prec_id::Int32 = Int32(0), pep_id::Int32 = Int32(0))</code></pre><p>Constructor for the <code>Precursor</code> struct. Given a list of amino acid residues, a charge, and an isotope state, makes a precursor object with the correct mz.  (link to Precursor)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/precursor.jl#L417-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Precursor" href="#Titus.Precursor"><code>Titus.Precursor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Precursor &lt;: Ion</p><p>Type that represents a precursor (A peptide parent ion)</p><p><strong>Fields</strong></p><ul><li>residues::Vector{Residue} – List of amino acid residues of the precursor in their appropriate order</li><li>mz::MzFeature – MZ with upper and lower bounds given a ppm tolerance</li><li>prec_id::UInt32 – Identifier of the precursor ion (parent ion of the fragment/transition)</li><li>charge::UInt8 – Charge of the fragment ion</li><li>isotope::UInt8 – Difference in number of neutrons from the monoisotopic fragment </li><li>pep_id::UInt32 – Identifier of the peptide from which precursor is derived</li></ul><p><strong>Examples</strong></p><ul><li><code>Precursor(residues::Vector{Residue}, mz::Float32, charge::UInt8,             isotope::UInt8,             pep_id::UInt32,            prec_id::UInt32;             ppm = Float32(20))</code> – default internal constructor</li><li><code>Precursor()</code> – constructor for null/empty precursor</li><li><code>Precursor(residues::Vector{Residue}, charge::UInt8,             isotope::UInt8 = UInt8(0),             pep_id::UInt32 = UInt32(0),            prec_id::UInt32 = UInt32(0)</code> – Constructor that calculates mz without having to supply it</li><li><code>Precursor(sequence::String; mods_dict::Dict{String, Float32} = Dict{String, Float32}(), charge::UInt8 = UInt8(2),             isotope::UInt8 = UInt8(0),             pep_id::UInt32 = UInt32(0),            prec_id::UInt32 = UInt32(0))</code> – Constructor that accepts a string representation of a peptide</li></ul><p><strong>GetterMethods</strong></p><ul><li>getResidues(precursor::Precursor) = precursor.residues</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/precursor.jl#L360-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Precursor-Tuple{String}" href="#Titus.Precursor-Tuple{String}"><code>Titus.Precursor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Precursor(sequence::String, mods_dict::Dict{String, Float32}, charge::Int32, isotope::Int32 = Int32(0), prec_id::Int32 = Int32(0), pep_id::Int32 = Int32(0))</code></pre><p>Alternate constructor for the <code>Precursor</code> struct. Can accept a string representation of a peptide and a <code>mods_dict</code>  and convert to residues <code>Array{Residue, 1}</code>.  (link to Precusor)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/precursor.jl#L435-L441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Precursor-Tuple{}" href="#Titus.Precursor-Tuple{}"><code>Titus.Precursor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Precursor()
Constructor for an &quot;empty&quot; or &quot;default&quot; precursor</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/precursor.jl#L447-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.PrecursorDatabase" href="#Titus.PrecursorDatabase"><code>Titus.PrecursorDatabase</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrecursorDatabase</code></pre><p>Data Structure that represents relations between precursors, peptides, peptide groups, and proteins</p><p><strong>Suggested Fields</strong></p><p>An implementation of <code>PrecursorTable</code> should have these fields </p><ul><li>id<em>to</em>prot::UnorderedDictionary{UInt32, Protein}– Maps from a protien identifier to a Protein</li><li>prot<em>to</em>id::UnorderedDictionary{String, UInt32} – Maps from a protein name to a protein identifier</li><li>id<em>to</em>pepGroup::UnorderedDictionary{UInt32, PeptideGroup} – Maps a PeptideGroup identifier to a PeptideGroup</li><li>pepGroup<em>to</em>id::UnorderedDictionary{String, UInt32} – Maps a PeptideGroup name/sequence to an identifier</li><li>id<em>to</em>pep::UnorderedDictionary{UInt32, Peptide} – Maps a peptide identifier to a peptide</li><li>id<em>to</em>prec::Dictionary{UInt32, Precursor} – Precursor has fields <code>pep_id</code> and <code>prec_id</code>. <code>pep_id</code>s are keys for <code>id_to_pep</code></li><li>sorted<em>prec</em>ids::Vector{UInt32} – </li><li>prec<em>id</em>to_transitions::Dictionary{UInt32, Vector{Transition}} –</li></ul><p><strong>GetterMethods</strong></p><ul><li>getIDToProt(p::PrecursorDatabase) = p.id<em>to</em>prot</li><li>getProtToID(p::PrecursorDatabase) = p.prot<em>to</em>id</li><li>getIDToPepGroup(p::PrecursorDatabase) = p.id<em>to</em>pepGroup</li><li>getPepGroupToID(p::PrecursorDatabase) = p.pepGroup<em>to</em>id</li><li>getIDToPep(p::PrecursorDatabase) = p.id<em>to</em>pep</li><li>getIDToPrec(p::PrecursorDatabase) = p.id<em>to</em>prec</li><li>getPrecIDToTransitions(p::PrecursorDatabase) = p.prec<em>id</em>to_transitions</li><li>getPrecursorIDs(p::PrecursorDatabase) = p.sorted<em>prec</em>ids</li><li>getProtID(p::PrecursorDatabase, protein::String)</li><li>getProtID(p::PrecursorDatabase, protein::Protein)</li><li>getPepGroup(p::PrecursorDatabase, pepGroup_id::UInt32)</li><li>getPepGroupID(p::PrecursorDatabase, peptide::String)</li><li>getPepGroupID(p::PrecursorDatabase, pepGroup::PeptideGroup)</li><li>getPep(p::PrecursorDatabase, pep_id::UInt32)</li><li>getPrecursor(p::PrecursorDatabase, prec_id::UInt32)</li><li>getTransitions(p::PrecursorDatabase, prec_id::UInt32)</li><li>getProtNamesFromPepSeq(p::PrecursorDatabase, peptide::String)</li><li>getProtNamesFromPepSeq(p::PrecursorDatabase, pepGroup::PeptideGroup)</li><li>getPepGroupsFromProt(p::PrecursorDatabase, protein::String)</li><li>getPepSeqsFromProt(p::PrecursorDatabase, protein::String)</li><li>getPepGroupsFromProt(p::PrecursorDatabase, prot_id::UInt32)</li><li>getPepSeqsFromProt(p::PrecursorDatabase, prot_id::UInt32)</li><li>getPepIDFromPrecID(p::PrecursorDatabase, prec_id::UInt32)</li></ul><p><strong>Methods</strong></p><ul><li>insertProtID!(p::PrecursorDatabase, protein::String, prot_id::UInt32)</li><li>insertProt!(p::PrecursorDatabase, protein::String, prot_id::UInt32)</li><li>insertPepGroupID!(p::PrecursorDatabase, peptide::String, pepGroup_id::UInt32)</li><li>insertPepGroup!(p::PrecursorDatabase, protein::String, peptide::String, pepGroup_id::UInt32)</li><li>setSortedPrecursorKeys!(p::PrecursorDatabase)</li><li>precursorRangeQuery(p::PrecursorDatabase, window<em>center::Float32, left</em>precursor<em>tolerance::Float32, right</em>precursor_tolerance::Float32)</li><li>addProteinToPepGroup!(pd::PrecursorDatabase, protein::String, peptide::String)</li><li>addPepGroupToProtein!(pd::PrecursorDatabase, protein::String, peptide::String)</li><li>addNewProtein!(pd::PrecursorDatabase, protein::String, prot_id::UInt32)</li><li>addNewPeptideGroup!(pd::PrecursorDatabase, peptide::String, pepGroup_id::UInt32, protein::String)</li><li>addPrecursors!(ptable::PrecursorDatabase, charges::Vector{UInt8}, isotopes::Vector{UInt8}, mods_dict::Dict{String, Float32})</li><li>addTransitions!(ptable::PrecursorDatabase, transition<em>charges::Vector{UInt8}, transition</em>isotopes::Vector{UInt8},b<em>start::Int64,y</em>start::Int64, fragment<em>match</em>ppm::Float32)</li></ul><p><strong>Notes</strong></p><p><code>PrecursorDatabase</code> keeps an account of relations between Proteins, PeptideGroups, Peptides, and Precursors. Each Protein, PeptideGroup, Peptide, and Precursor has a unique UInt32 indentifier.  Each also has a string name. See <code>Protein</code>, <code>PeptideGroup</code>, <code>Peptide</code> and <code>Precursor</code>.  Proteins map to one or more PeptideGroups. PeptideGroups map to one or more Peptides,  and each Peptide maps to one or more precursors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/getPrecursors.jl#L136-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.PrecursorTable" href="#Titus.PrecursorTable"><code>Titus.PrecursorTable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrecursorTable &lt;: PrecursorDatabase</code></pre><p>Inherits from <code>PrecursorDatabase</code>. Minimal implementation of methods required for <code>PrecursorDatabase</code></p><p><strong>Fields</strong></p><ul><li>id<em>to</em>prot::UnorderedDictionary{UInt32, Protein}– Maps from a protien identifier to a <code>Protein</code>`</li><li>prot<em>to</em>id::UnorderedDictionary{String, UInt32} – Maps from a protein name to a protein identifier</li><li>id<em>to</em>pepGroup::UnorderedDictionary{UInt32, PeptideGroup} – Maps a peptide group identifier to a <code>PeptideGroup</code>`</li><li>pepGroup<em>to</em>id::UnorderedDictionary{String, UInt32} – Maps a <code>PeptideGroup</code>` name/sequence to an identifier</li><li>id<em>to</em>pep::UnorderedDictionary{UInt32, Peptide} – Maps a peptide identifier to a <code>Peptide</code></li><li>id<em>to</em>prec::Dictionary{UInt32, Precursor} – Maps a precursor identifier to a <code>Precursor</code></li><li>sorted<em>prec</em>ids::Vector{UInt32} – Precursor ID&#39;s for precursors in <code>id_to_prec</code> sorted by m/z </li><li>prec<em>id</em>to_transitions::Dictionary{UInt32, Vector{Transition}} –  Maps a precursor identifier to a Vector{Transition} (fragment ions)</li></ul><p><strong>Examples</strong></p><ul><li><code>PrecursorTable() = PrecursorTable(   UnorderedDictionary{UInt32, Protein}(),   UnorderedDictionary{String, UInt32}(),   UnorderedDictionary{UInt32, PeptideGroup}(),   UnorderedDictionary{String, UInt32}(),   UnorderedDictionary{UInt32, Peptide}(),   Vector{Precursor}())</code> – constructor for a placeholder </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/getPrecursors.jl#L204-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Protein" href="#Titus.Protein"><code>Titus.Protein</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Protein</code></pre><p>Type that represents a protein. </p><p><strong>Fields</strong></p><ul><li>sequence::String – Sequence of the peptide</li><li>pep<em>group</em>id::UInt32– Identifier of thes <code>PeptideGroup</code>s contained by this <code>Protein</code></li></ul><p><strong>Examples</strong></p><ul><li><code>Protein(name::String) = Protein(name, Set{UInt32}())</code> – constructor for an placeholder </li></ul><p><strong>GetterMethods</strong></p><ul><li>getName(p::Protein) = p.name</li><li>getPepGroupIDs(p::Protein) = p.pep<em>group</em>ids</li></ul><p><strong>Methods</strong></p><ul><li>addPepGroupID!(p::Protein, pep<em>group</em>id::UInt32)</li></ul><p><strong>Notes</strong></p><p>Protein &gt; PeptideGroup &gt; Peptide &gt; Precursor</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/getPrecursors.jl#L93-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Residue" href="#Titus.Residue"><code>Titus.Residue</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Residue</p><p>Type that represents a (potentially modified) amino acid within a peptide</p><p><strong>Fields</strong></p><ul><li>mass:Float32 – mass of the amino acid</li></ul><p><strong>Examples</strong></p><ul><li><code>Residue(aa::AA)</code> – default constructor</li><li><code>Residue(aa::Char) = Residue(AA(aa))</code></li><li><code>Residue(aa::AA, mod::Mod) = Residue(getMass(mod)+getMass(aa))</code></li><li><code>Residue(residue::String, mods_dict::Dict{String, Float32}) = Residue(AA(residue[1]), Mod(residue, mods_dict))</code></li><li><code>Residue(residue::String) = Residue(residue, Dict{String, Float32}())</code></li><li><code>Residue(residue::String, mod_mass::Float32) = Residue(getMass(AA(residue[1])) + mod_mass)</code></li><li><code>Residue(residue::Char, mod_mass::Float32) = Residue(getMass(AA(residue)) + mod_mass)</code></li></ul><p><strong>Getter methods</strong></p><ul><li>getMass(residue::Residue) = residue.mass</li></ul><p><strong>See Also</strong></p><ul><li><code>getResidues(sequence::String,               mods_dict::Dict{String, Float32} = default_mods)</code> – Gets a vector of residues given a string  representation of an amino acid sequence</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/precursor.jl#L153-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Transition" href="#Titus.Transition"><code>Titus.Transition</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Transition &lt;: Ion</p><p>Type that represents transition (fragment ion of a peptide)</p><p><strong>Fields</strong></p><ul><li>mz::MzFeature – MZ with upper and lower bounds given a ppm tolerance</li><li>prec_id::UInt32 – Identifier of the precursor ion (parent ion of the fragment/transition)</li><li>ion_type::Char  – Type of transition. For example &#39;b&#39; for b ion or &#39;y&#39; for y ion</li><li>ind::UInt8 – Position of fragment ion with reference to parent ion. (A b5+2 ion should have an ind equal to 5)</li><li>charge::UInt8 – Charge of the fragment ion</li><li>isotope::UInt8 – Difference in number of neutrons from the monoisotopic fragment </li></ul><p><strong>Examples</strong></p><ul><li><code>Transition(frag_mz::Float32, prec_id::UInt32, ion_type::Char, ind::UInt8,              charge::UInt8,              isotope::UInt8;              ppm = Float32(20))</code> – default internal constructor</li><li><code>Transition(residues::Vector{Residue}; ion_type::Char = &#39;y&#39;, charge::UInt8 = UInt8(1),              ind::UInt8 = UInt8(length(residues)),              isotope::UInt8 = UInt8(0),              prec_id::UInt32 = UInt32(0))</code> – constructor that calculates the appropriate mz</li></ul><p><strong>GetterMethods</strong></p><ul><li>getIonType(transition::Transition) = transition.ion_type</li><li>getInd(transition::Transition) = transition.ind</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/precursor.jl#L283-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Transition-Tuple{Vector{Residue}}" href="#Titus.Transition-Tuple{Vector{Residue}}"><code>Titus.Transition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Transition(residues::Vector{Residue}; ion_type::Char = &#39;y&#39;, charge::UInt8 = UInt8(1), ind::UInt8 = UInt8(length(residues)), isotope::UInt8 = UInt8(0), prec_id::UInt32 = UInt32(0))

Constructor for the `Transition` struct. Given a list of amino acid residues, ion type (b or y), charge state, and isotopic state makes a transition with the correct mz.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/precursor.jl#L330-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.addPepGroup!-Tuple{PrecursorDatabase, String, UInt32, Set{UInt32}, String}" href="#Titus.addPepGroup!-Tuple{PrecursorDatabase, String, UInt32, Set{UInt32}, String}"><code>Titus.addPepGroup!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>addNewPeptideGroup!(pd::PrecursorDatabase, peptide::String, pepGroup_id::UInt32, protein::String)</p><p>Create a new <code>PeptideGroup</code> and peptide group id and add them to the lookup tables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/getPrecursors.jl#L380-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.addPepGroupToProtein!-Tuple{PrecursorDatabase, UInt32, UInt32}" href="#Titus.addPepGroupToProtein!-Tuple{PrecursorDatabase, UInt32, UInt32}"><code>Titus.addPepGroupToProtein!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>addPepGroupToProtein!(pd::PrecursorDatabase, protein::String, peptide::String)</p><p>For the protein to which the <code>peptide</code> belongs, add the correct peptide group id to its <code>pep_group_ids</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/getPrecursors.jl#L354-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.addPrecursors!-Tuple{PrecursorDatabase, Vector{UInt8}, Vector{UInt8}, Dict{String, Float32}}" href="#Titus.addPrecursors!-Tuple{PrecursorDatabase, Vector{UInt8}, Vector{UInt8}, Dict{String, Float32}}"><code>Titus.addPrecursors!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addPrecursors!(ptable::PrecursorTable, charges::Vector{UInt8}, isotopes::Vector{UInt8}, mods_dict::Dict{String, Float32})</code></pre><p>Modifies a <code>PrecursorDatabase</code> to fill the <code>precursors</code> field. Gets a <code>Precursor</code> for each unique <code>Peptide</code> in <code>ptable</code>. Sorts the  precursors in order of increasing mz.   </p><p><strong>Input</strong></p><ul><li><code>ptable::PrecursorTable</code> – See <code>PrecursorTable</code></li><li><code>charges::Vector{UInt8}</code> – Get a precursor with these charges for each Peptide in <code>ptable</code></li><li><code>isotopes::Vector{UInt8}</code> – Get a precursor with these isotopes for each Peptide in <code>ptable</code></li><li><code>mods_dict::Dict{String, Float32}</code> – Dict mapping modifications to their masses</li></ul><p><strong>Output</strong></p><ul><li>Fills the <code>id_to_prec</code> and <code>sorted_prec_ids</code> fields in a <code>PrecursorDatabase</code> </li></ul><p><strong>Examples</strong></p><p>test<em>mods::Dict{String, Float32} =  Dict{String, Float32}(     &quot;Carb&quot; =&gt; Float32(57.021464),     &quot;Harg&quot; =&gt; Float32(10),     &quot;Hlys&quot; =&gt; Float32(8), ) fixed</em>mods = [(p=r&quot;C&quot;, r=&quot;C[Carb]&quot;)] var_mods = [(p=r&quot;(K<span>$)&quot;, r=&quot;[Hlys]&quot;), (p=r&quot;(R$</span>)&quot;, r=&quot;[Harg]&quot;)]</p><p>testPtable = PrecursorTable() buildPrecursorTable!(testPtable, fixed<em>mods, var</em>mods, 2, &quot;../data/peptide<em>lists/PROT</em>PEPTIDE<em>TEST1.txt&quot;) getPrecursors!(testPtable, UInt8[2, 3, 4], UInt8[0], test</em>mods)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/getPrecursors.jl#L398-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.addProtein!-Tuple{PrecursorDatabase, String, UInt32}" href="#Titus.addProtein!-Tuple{PrecursorDatabase, String, UInt32}"><code>Titus.addProtein!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>addNewProtein!(pd::PrecursorDatabase, protein::String, prot_id::UInt32)</p><p>Create a new <code>Protein</code> and protein id and add them to the lookup tables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/getPrecursors.jl#L369-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.addProteinToPepGroup!-Tuple{PrecursorDatabase, UInt32, UInt32}" href="#Titus.addProteinToPepGroup!-Tuple{PrecursorDatabase, UInt32, UInt32}"><code>Titus.addProteinToPepGroup!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>addProteinToPepGroup!(pd::PrecursorDatabase, protein::String, peptide::String)</p><p>For the PeptideGroup to which &quot;peptide&quot; belongs, add the protein to its <code>prot_ids</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/getPrecursors.jl#L340-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.addTransitions!-Tuple{PrecursorDatabase, Vector{UInt8}, Vector{UInt8}, Int64, Int64, Float32}" href="#Titus.addTransitions!-Tuple{PrecursorDatabase, Vector{UInt8}, Vector{UInt8}, Int64, Int64, Float32}"><code>Titus.addTransitions!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addTransitions!(ptable::PrecursorDatabase, transition_charges::Vector{UInt8}, transition_isotopes::Vector{UInt8},b_start::Int64,y_start::Int64, fragment_match_ppm::Float32)</code></pre><p>Modifies a <code>PrecursorDatabase</code> to add <code>Transition</code>s to the &#39;prec<em>id</em>to<em>transitions&#39; field corresponding to all <code>Precursor</code>s  in the `id</em>to_prec` field. Gets all transitions  for the specified charge and isotopic states for all precursors in the PrecursorDatabase. </p><p><strong>Input</strong></p><ul><li><code>ptable::PrecursorTable</code> – See <code>PrecursorTable</code></li><li><code>transition_charges::Vector{UInt8}</code> – Get <code>Transition</code>s with these charges for each <code>Precursor</code> in <code>ptable</code></li><li><code>transition_isotopes::Vector{UInt8}</code> – Get <code>Transition</code>s with these isotopes for each Precursor<code>in</code>ptable`</li><li><code>b_start::Int64</code> – Get transitions bn+x and higher. At <code>3</code> would exclude b2 and b1 ions</li><li><code>y_start::Int64</code> – Same as <code>b_start</code> but for y ions</li><li><code>fragment_match_ppm::Float32</code> – Fragment match tolerance for the precursors</li></ul><p><strong>Output</strong></p><ul><li>Fills the <code>prec_id_to_transitions</code> field in a <code>PrecursorDatabase</code> </li></ul><p><strong>Examples</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/getPrecursors.jl#L449-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.getBIonModifier-Tuple{UInt8}" href="#Titus.getBIonModifier-Tuple{UInt8}"><code>Titus.getBIonModifier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getBIonModifier(charge::UInt8)</code></pre><p>Mass modification that needs to be added to b-ions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/precursor.jl#L463-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.getFragIons-Tuple{Vector{Residue}}" href="#Titus.getFragIons-Tuple{Vector{Residue}}"><code>Titus.getFragIons</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getFragIons(residues::Vector{Residue}; charge::UInt8 = UInt8(1), isotope::UInt8 = UInt8(0), y_start::Int = 3, b_start::Int = 3)</code></pre><p>Uses calls to <code>getIonSeries</code> to concatenate both the b and y ion series together in a single Vector{Float32}</p><p><strong>Input</strong></p><ul><li><code>residues::Vector{Residue}</code>: – List of amino acid residues in the peptide ion</li><li><code>charge::UInt8</code> – Charge of the fragment ions</li><li><code>b_start::Int=3</code>  – Index of first ion the the b-ion series to compute. </li><li><code>y_start::Int=3</code>  – Index of first ion the the y-ion series to compute. </li><li><code>isotope::UInt8=UInt8(0)</code> – Diference in the number of isotopes from the monoisotopic ion. </li></ul><p><strong>Output</strong></p><p>A Vector{Float32} wich each m/z in the ion series</p><p><strong>Notes</strong></p><ul><li>The <code>modifier</code> argument ought to depend on the kind of ion. For a &#39;b&#39; ion series PROTON*charge is appropriate,</li></ul><p>but for a &#39;y&#39; ion series, PROTON*charge + H2O would be appropriate. </p><ul><li>Will not allow the index of the ion to be equal to or less than the charge. For example,</li></ul><p>b2+2 ions could only be calculated in error and are therefore excluded even if <code>start</code>  is set to 2. </p><ul><li>If <code>start</code> exceeds length(residues)-1, then only the N-1 ion is calculated, that is,</li></ul><p>the highest mass ion in the series. </p><p><strong>Examples</strong></p><p>#Gets the b3+1-b6+1 and y3+1-y6+1 ions</p><pre><code class="language-julia-repl hljs">julia&gt; getFragIons(reverse(getResidues(&quot;PEPTIDE&quot;)), b_start = 3, y_start = 3)
8-element Vector{Float32}:
 358.16083
 459.2085
 556.2612
 685.30383
 342.16595
 443.21365
 556.29767
 671.3246</code></pre><p><strong>See Also</strong></p><p>Alternate convience methods</p><ul><li><p><code>getFragIons(residues::Vector{Residue}; charge::UInt8 = UInt8(1),             isotope::UInt8 = UInt8(0),              y_start::Int = 3,              b_start::Int = 3)</code> - Default method</p></li><li><p><code>getFragIons(precursor::Precursor; charge::UInt8 = UInt8(1),              isotope::UInt8 = UInt8(0),              y_start::Int = 3,              b_start::Int = 3)</code> - Can supply a <code>Precursor</code> rather than a  <code>Vector{Residues}</code> input</p></li><li><p><code>getFragIons(precursor::Precursor,charges::Vector{UInt8},              isotopes::Vector{UInt8};              y_start::Int = 3,              b_start::Int = 3)</code> - Gets b and y ion seriers for multiple charge and isotopic states</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/precursor.jl#L649-L711">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.getIonMZ-Tuple{Vector{Residue}, Char, UInt8}" href="#Titus.getIonMZ-Tuple{Vector{Residue}, Char, UInt8}"><code>Titus.getIonMZ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getIonMZ(residues::Vector{Residue}, ion_type::Char, charge::UInt8; isotope::UInt8 = UInt8(0))</code></pre><p>Alternate getIonMZ method that chooses the correct mass modifier for &#39;b&#39;, &#39;y&#39;, and &#39;p&#39; ions respectively. </p><p><strong>Input</strong></p><pre><code class="nohighlight hljs">- `residues::Vector{Residue}`: -- List of amino acid residues in the peptide ion
- `ion_type::Char` -- Type of fragment ion. Currently supports, &#39;b&#39;, &#39;y&#39;, and &#39;p&#39;. 
- `charge::UInt8` -- Charge of the ion
- `isotope::UInt8=UInt8(0)` -- Diference in the number of isotopes from the monoisotopic ion.</code></pre><p><strong>Notes</strong></p><pre><code class="nohighlight hljs">See main method
    getIonMZ(residues::Vector{Residue}, charge::UInt8; modifier::Float32 = PROTON*charge + H2O, isotope::UInt8 = UInt8(0))
for more details</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/precursor.jl#L526-L542">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.getIonMZ-Tuple{Vector{Residue}, UInt8}" href="#Titus.getIonMZ-Tuple{Vector{Residue}, UInt8}"><code>Titus.getIonMZ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getIonMZ(residues::Vector{Residue}, charge::UInt8; modifier::Float32 = PROTON*charge + H2O, isotope::UInt8 = UInt8(0))::Float32</code></pre><p>Get the mz ratio of an ion</p><p><strong>Input</strong></p><ul><li><code>residues::Vector{Residue}</code>: – List of amino acid residues in the peptide ion</li><li><code>charge::UInt8</code> – Charge of the ion</li><li><code>modifier::Float32=PROTON*charge + H2O</code> – Added to the mass of the ion</li><li><code>isotope::UInt8=UInt8(0)</code> – Diference in the number of isotopes from the monoisotopic ion. </li></ul><p><strong>Output</strong></p><p>A Float32 representing the mass-to-charge ratio (m/z) of an ion</p><p><strong>Notes</strong></p><p>The <code>modifier</code> argument ought to depend on the kind of ion. For B ions PROTON<em>charge is appropriate, but for &#39;y&#39; or precursor ions, PROTON</em>charge + H2O would be appropriate.</p><p><strong>Algorithm</strong></p><p>Sum the amino acid residue masses, add <code>modifier</code> + isotope*NEUTRON and then divide the total by the charge. </p><p><strong>Examples</strong></p><p>#Gets the b6+1 ion MZ</p><pre><code class="language-julia-repl hljs">julia&gt; getIonMZ(getResidues(&quot;PEPTIDE&quot;)[1:6], UInt8(1), modifier = PROTON)
653.314f0</code></pre><p>#Gets the y6+1 ion MZ</p><pre><code class="language-julia-repl hljs">julia&gt; getIonMZ(reverse(getResidues(&quot;PEPTIDE&quot;))[1:6], UInt8(1))
703.3144f0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/precursor.jl#L479-L517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.getIonSeries-Tuple{Vector{Residue}, UInt8}" href="#Titus.getIonSeries-Tuple{Vector{Residue}, UInt8}"><code>Titus.getIonSeries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getIonSeries(residues::Vector{Residue}, charge::UInt8; start::Int = 3, modifier::Float32 = PROTON*charge + H2O, isotope::UInt8 = UInt8(0))</code></pre><p>Gets the m/z&#39;s for an ion series as a Vector{Float32}. </p><p><strong>Input</strong></p><ul><li><code>residues::Vector{Residue}</code>: – List of amino acid residues in the peptide ion</li><li><code>charge::UInt8</code> – Charge of the fragment ions</li><li><code>start::Int=3</code>  – Index of first ion the the series to compute.</li><li><code>isotope::UInt8=UInt8(0)</code> – Diference in the number of isotopes from the monoisotopic ion. </li></ul><p><strong>Output</strong></p><p>A Vector{Float32} wich each m/z in the ion series</p><p><strong>Notes</strong></p><ul><li>The <code>modifier</code> argument ought to depend on the kind of ion. For a &#39;b&#39; ion series PROTON*charge is appropriate,</li></ul><p>but for a &#39;y&#39; ion series, PROTON*charge + H2O would be appropriate. </p><ul><li>Will not allow the index of the ion to be equal to or less than the charge. For example,</li></ul><p>b2+2 ions could only be calculated in error and are therefore excluded even if <code>start</code>  is set to 2. </p><ul><li>If <code>start</code> exceeds length(residues)-1, then only the N-1 ion is calculated, that is,</li></ul><p>the highest mass ion in the series. </p><p><strong>Examples</strong></p><p>#Gets the y3+2 through y6+2 ions</p><pre><code class="language-julia-repl hljs">julia&gt; getIonSeries(reverse(getResidues(&quot;PEPTIDE&quot;)), UInt8(2), start = 3)
4-element view(::Vector{Float32}, 3:6) with eltype Float32:
 188.58934
 239.11317
 287.63956
 352.16086</code></pre><p>#Gets the b4+2 through b6+2 ions</p><pre><code class="language-julia-repl hljs">julia&gt; getIonSeries(getResidues(&quot;PEPTIDE&quot;), UInt8(2), start = 4, modifier = PROTON*UInt8(2))
3-element view(::Vector{Float32}, 4:6) with eltype Float32:
 213.10518
 269.6472
 327.16064</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/precursor.jl#L584-L632">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.getNearest-Tuple{Transition, Vector{Union{Missing, Float32}}, Int64}" href="#Titus.getNearest-Tuple{Transition, Vector{Union{Missing, Float32}}, Int64}"><code>Titus.getNearest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getNearest(transition::Transition, masses::Vector{Union{Missing, Float32}}, peak::Int; δ = 0.01)</code></pre><p>Finds the <code>peak</code> (index of <code>masses</code>) nearest in mass to the <code>transition</code> but still within the tolerance (getLow(transition)&lt;masses[peak]&lt;getHigh(transition)).  Starts searching at initially supplied <code>peak</code> and increases the index until outside the tolerance. There could be multiple peaks within the tolerance,  and this function selects the one with the lowest mass error to the fragment ion. </p><p><strong>Input</strong></p><ul><li><code>transition::Transition</code>: – Represents a fragment ion</li><li><code>masses::Vector{Union{Missing, Float32}}</code> – Mass list from a centroided mass spectrum. MUST BE SORTED IN ASCENDING ORDER. </li><li><code>peak::Int</code> – An index for a mass in <code>masses</code></li><li><code>δ</code> – A mass offset that can be applied to each mass in <code>masses</code> </li></ul><p><strong>Output</strong></p><p>An Int representing the index of the m/z in <code>masses</code> nearest in m/z to that of the fragment m/z. </p><p><strong>Notes</strong></p><ul><li>It is assumed that masses is sorted in ascending order. </li><li>In practice, when called from <code>matchPeaks!</code>, masses[peak] will already be within the fragment m/z tolerance.</li></ul><p>Usually there will not be another peak in <code>masses</code> where this is true, but it is possible for multiple peaks to  fall within the tolerance. The purpose of this function is to select the best peak (closes in mass) when this happens.  </p><p><strong>Algorithm</strong></p><p><strong>Examples</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/matchpeaks.jl#L63-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.getPrecursors-Tuple{Vector{Residue}}" href="#Titus.getPrecursors-Tuple{Vector{Residue}}"><code>Titus.getPrecursors</code></a> — <span class="docstring-category">Method</span></header><section><div><p>getPrecursors(residues::Vector{Residue}; charges::Vector{UInt8} = UInt8[1,2],isotopes::Vector{UInt8}=UInt8[0],pep_id::UInt32=UInt32(0)) </p><p>Alternate constructor for the <code>Precursor</code> struct that Can accept a string representation of a peptide</p><p><strong>Input</strong></p><p><strong>Output</strong></p><p><strong>Notes</strong></p><p>(link to getResidues())</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/precursor.jl#L563-L575">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.getYIonModifier-Tuple{UInt8}" href="#Titus.getYIonModifier-Tuple{UInt8}"><code>Titus.getYIonModifier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getYIonModifier(charge::UInt8)</code></pre><p>Mass modification that needs to be added to y-ions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/precursor.jl#L471-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.matchPeaks!-Tuple{Vector{FragmentMatch}, Vector{Transition}, Vector{Union{Missing, Float32}}, Vector{Union{Missing, Float32}}, Float64, UInt32, UInt32}" href="#Titus.matchPeaks!-Tuple{Vector{FragmentMatch}, Vector{Transition}, Vector{Union{Missing, Float32}}, Vector{Union{Missing, Float32}}, Float64, UInt32, UInt32}"><code>Titus.matchPeaks!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function matchPeaks!(matches::Vector{FragmentMatch}, Transitions::Vector{Transition}, masses::Vector{Union{Missing, Float32}}, intensities::Vector{Union{Missing, Float32}}, δ::Float64)</code></pre><p>Finds the best matching peak in a mass spectrum for each transition/fragment ion supplied if the match is within the fragment tolerance.      Adds each FragmentMatch to <code>matches</code> if not already present. Otherwise,      modifies an existing match (see setFragmentMatch!).</p><p><strong>Input</strong></p><ul><li><code>matches::Vector{FragmentMatch}</code>: – A list representing fragment ions that match peaks in the mass spectrum (<code>masses</code>)</li><li><code>Transitions::Vector{Transition</code> – A list of fragment ions to search for in the spectrum (<code>masses</code>). MUST BE SORTED IN ASCENDING ORDER BY <code>getMZ(transition)</code></li><li><code>masses::Vector{Union{Missing, Float32}}</code> – Mass list from a centroided mass spectrum. MUST BE SORTED IN ASCENDING ORDER.</li><li><code>intensities::Vector{Union{Missing, Float32}}</code> – The intensity list from a centroided mass spectrum. Must be the same length as <code>masses</code></li><li><code>δ::Float64</code> – A mass offset that can be applied to each mass in <code>masses</code></li></ul><p><strong>Output</strong></p><p>Modifies <code>matches[match]</code> if match is &lt;= lenth(matches). Otherwise adds a new FragmentMatch at <code>matches[match]</code></p><p><strong>Notes</strong></p><ul><li>Updating a match in <code>matches</code> could be useful if researching the same spectra many times at different mass offsets with <code>matchPeaks!</code>    This could be done to calculate a cross correlatoin score for example. If a spectrum is only searched once, then matches should   only be added to <code>matches</code> and existing ones never modified. </li><li>The fragment tolerance is specified by each <code>Transition</code>. A <code>Transition&lt;:Ion</code> has a field <code>mz::MzFeature</code> which specifies the monoisotopic mass   and also upper and lower bounds (the tolerance). See getLow(ion::Ion) and getHigh(ion::Ion). This is why the user need not supply a fragment tolerance to <code>matchPeaks!</code> </li><li><code>masses</code> and <code>intensities</code> contain type unions Union{Missing, Float32}. This method does nothing to check for Missing values, and indeed,   it is assumed that there are none, and the presence of any Missing values will cause an error. The reason for the type union is an idiosyncracy   of the Arrow.jl package and how it implements nested data types in Arrow files. </li></ul><p><strong>Algorithm</strong></p><p>Given a list of fragment ions and a centroided mass spectrum both sorted by m/z, it is efficient to search the spetrum for matches in a &quot;single pass&quot; through the spectrum. If there are T transitions and P peaks should be O(T+P). If there are multiple peaks within the tolerance for a given  fragment ion, the peak closest in m/z to the fragment ion is chosen. It is possible to assign the same peak to multiple fragment ions, but  each fragment ion is only assigned to 0 or 1 peaks. </p><p><strong>Examples</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/matchpeaks.jl#L164-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.matchPeaks-Tuple{Vector{Transition}, Vector{Union{Missing, Float32}}, Vector{Union{Missing, Float32}}}" href="#Titus.matchPeaks-Tuple{Vector{Transition}, Vector{Union{Missing, Float32}}, Vector{Union{Missing, Float32}}}"><code>Titus.matchPeaks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function matchPeaks!(matches::Vector{FragmentMatch}, Transitions::Vector{Transition}, masses::Vector{Union{Missing, Float32}}, intensities::Vector{Union{Missing, Float32}}, δ::Float64)</code></pre><p>A wrapper for calling <code>matchPeaks</code> at different to search spectra at a list of mass offset.      Each all to <code>matchPeaks</code> Finds the best matching peak in a mass spectrum for each transition/fragment ion supplied if the match is within the fragment tolerance.      Adds each FragmentMatch to <code>matches</code> if not already present. Otherwise, modifies an existing match (see setFragmentMatch!). (see <code>matchPeaks</code> for additional details)</p><p><strong>Input</strong></p><ul><li><code>matches::Vector{FragmentMatch}</code>: – A list representing fragment ions that match peaks in the mass spectrum (<code>masses</code>)</li><li><code>Transitions::Vector{Transition</code> – A list of fragment ions to search for in the spectrum (<code>masses</code>). MUST BE SORTED IN ASCENDING ORDER BY <code>getMZ(transition)</code></li><li><code>masses::Vector{Union{Missing, Float32}}</code> – Mass list from a centroided mass spectrum. MUST BE SORTED IN ASCENDING ORDER.</li><li><code>intensities::Vector{Union{Missing, Float32}}</code> – The intensity list from a centroided mass spectrum. Must be the same length as <code>masses</code></li><li><code>δ::Float64</code> – A mass offset that can be applied to each mass in <code>masses</code></li></ul><p><strong>Output</strong></p><p>Modifies <code>matches[match]</code> if match is &lt;= lenth(matches). Otherwise adds a new FragmentMatch at <code>matches[match]</code></p><p><strong>Notes</strong></p><ul><li>Searching a mass spectrum many times at different mass offsets could be useful for caculating cross correlation scores. </li></ul><p><strong>Algorithm</strong></p><pre><code class="nohighlight hljs">See `matchPeaks`</code></pre><p><strong>Examples</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/matchpeaks.jl#L232-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.precursorRangeQuery-Tuple{PrecursorDatabase, Float32, Float32, Float32}" href="#Titus.precursorRangeQuery-Tuple{PrecursorDatabase, Float32, Float32, Float32}"><code>Titus.precursorRangeQuery</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">precursorRangeQuery(p::PrecursorDatabase, window_center::Float32, left_precursor_tolerance::Float32, right_precursor_tolerance::Float32)</code></pre><p>Finds precursor IDs mapping to <code>Precursor</code>s with m/z ratios in the tolerance specified by <code>window_center</code>, <code>left_precursor_tolerance</code>, and <code>right_precursor_tolerance</code> Assumes the p.id<em>to</em>prec dictionary is already sorted. see <code>setSortedPrecursorKeys!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/getPrecursors.jl#L326-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.setFragmentMatch!-Tuple{Vector{FragmentMatch}, Int64, Transition, Float32, Float32, Int64, UInt32, UInt32}" href="#Titus.setFragmentMatch!-Tuple{Vector{FragmentMatch}, Int64, Transition, Float32, Float32, Int64, UInt32, UInt32}"><code>Titus.setFragmentMatch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setFragmentMatch!(matches::Vector{FragmentMatch}, match::Int, transition::Transition, mass::Float32, intensity::Float32, peak_ind::Int64)</code></pre><p>Adds a FragmentMatch to <code>matches</code> if <code>match</code> is not an index in <code>matches</code>, otherwise, updates the match.</p><p><strong>Input</strong></p><ul><li><code>hits::Vector{FragmentMatch}</code>: – Represents a fragment ion</li><li><code>match::Int</code> – Index of the match. Must be &lt;=N+1 where N is length(hits) </li><li><code>mass::Float32</code> – m/z of the emperical peak matched to the transition</li><li><code>intensity::Float32</code> – intensity of the emperical peak matched to the transition</li><li><code>peak_ind</code> – unique index of the emperical peak matched to the transition</li></ul><p><strong>Output</strong></p><p>Modifies <code>matches[match]</code> if match is &lt;= lenth(matches). Otherwise adds a new FragmentMatch at <code>matches[match]</code></p><p><strong>Notes</strong></p><ul><li>Updating a match in <code>matches</code> could be useful if researching the same spectra many times at different mass offsets with <code>matchPeaks!</code>    This could be done to calculate a cross correlatoin score for example. If a spectrum is only searched once, then matches should   only be added to <code>matches</code> and existing ones never modified. </li><li>Recording the <code>peak_ind</code> could be useful, for example, &quot;chimeric&quot; scoring of a spectrum from a Vector{FragmentMatch} type. The best scoring precursor would   have fragments matching to known <code>peak_ind</code>. The Vector{FragmentMatch} could be rescored but excluding FragmentMatches corresponding   to those peak_ind&#39;s. This would enable a simple chimeric spectra scoring that would not involve completely researching the spectrum (making an additional call to <code>matchPeaks</code>). </li></ul><p><strong>Algorithm</strong></p><p><strong>Examples</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/matchpeaks.jl#L118-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.setSortedPrecursorKeys!-Tuple{PrecursorDatabase}" href="#Titus.setSortedPrecursorKeys!-Tuple{PrecursorDatabase}"><code>Titus.setSortedPrecursorKeys!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setSortedPrecursorKeys!(p::PrecursorDatabase)</code></pre><p>Sorts precursors in the <code>PrecursorDatabase</code> by their m/z ratio. First sorts the Dictionary{UInt32, Precursor} <code>p.id_to_prec</code> that maps precursor id&#39;s to <code>Precursor</code>s. Sets <code>p.sorted_prec_ids</code> as a vector of the ID&#39;s for these precursors (sorted). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/2c53771444bdd39129ea2f2a4859036bbb0bf83a/src/getPrecursors.jl#L310-L316">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="examples/test/">« -</a><a class="docs-footer-nextpage" href="license/">License »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 24 May 2023 21:30">Wednesday 24 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
