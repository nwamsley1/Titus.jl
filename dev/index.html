<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index · Titus.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://nwamsley1.github.io/Titus.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="README/">Titus.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="README/">Introduction</a></li><li><a class="tocitem" href="gettingstarted/">-</a></li><li><span class="tocitem">User&#39;s guide</span><ul><li><a class="tocitem" href="interface/">-</a></li></ul></li><li><span class="tocitem">Developer&#39;s guide</span><ul><li><a class="tocitem" href="wrappers/">-</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/test/">-</a></li></ul></li><li class="is-active"><a class="tocitem" href>Index</a></li><li><a class="tocitem" href="license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nwamsley1/Titus.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><ul><li><a href="#Titus.FragmentMatch"><code>Titus.FragmentMatch</code></a></li><li><a href="#Titus.Ion"><code>Titus.Ion</code></a></li><li><a href="#Titus.MzFeature"><code>Titus.MzFeature</code></a></li><li><a href="#Titus.Precursor-Tuple{}"><code>Titus.Precursor</code></a></li><li><a href="#Titus.Precursor-Union{Tuple{T}, Tuple{Array{Residue{T}, 1}, UInt8}, Tuple{Array{Residue{T}, 1}, UInt8, UInt8}, Tuple{Array{Residue{T}, 1}, UInt8, UInt8, UInt32}, Tuple{Array{Residue{T}, 1}, UInt8, UInt8, UInt32, UInt32}} where T&lt;:AbstractFloat"><code>Titus.Precursor</code></a></li><li><a href="#Titus.Precursor"><code>Titus.Precursor</code></a></li><li><a href="#Titus.Precursor-Union{Tuple{String}, Tuple{T}} where T&lt;:AbstractFloat"><code>Titus.Precursor</code></a></li><li><a href="#Titus.Residue"><code>Titus.Residue</code></a></li><li><a href="#Titus.Transition"><code>Titus.Transition</code></a></li><li><a href="#Titus.Transition-Union{Tuple{Array{Residue{T}, 1}}, Tuple{T}} where T&lt;:AbstractFloat"><code>Titus.Transition</code></a></li><li><a href="#Titus.getBIonModifier-Union{Tuple{UInt8}, Tuple{T}, Tuple{UInt8, T}} where T&lt;:AbstractFloat"><code>Titus.getBIonModifier</code></a></li><li><a href="#Titus.getFragIons-Union{Tuple{Array{Residue{T}, 1}}, Tuple{T}} where T&lt;:AbstractFloat"><code>Titus.getFragIons</code></a></li><li><a href="#Titus.getIonMZ-Union{Tuple{T}, Tuple{Array{Residue{T}, 1}, UInt8}} where T&lt;:AbstractFloat"><code>Titus.getIonMZ</code></a></li><li><a href="#Titus.getIonMZ-Union{Tuple{T}, Tuple{Array{Residue{T}, 1}, Char, UInt8}} where T&lt;:AbstractFloat"><code>Titus.getIonMZ</code></a></li><li><a href="#Titus.getIonSeries-Union{Tuple{T}, Tuple{Array{Residue{T}, 1}, UInt8}} where T&lt;:AbstractFloat"><code>Titus.getIonSeries</code></a></li><li><a href="#Titus.getNearest-Union{Tuple{U}, Tuple{T}, Tuple{Transition, Array{Union{Missing, T}, 1}, Int64}} where {T, U&lt;:AbstractFloat}"><code>Titus.getNearest</code></a></li><li><a href="#Titus.getPrecursors-Union{Tuple{Array{Residue{T}, 1}}, Tuple{T}} where T&lt;:AbstractFloat"><code>Titus.getPrecursors</code></a></li><li><a href="#Titus.getYIonModifier-Union{Tuple{UInt8}, Tuple{T}, Tuple{UInt8, T}, Tuple{UInt8, T, T}} where T&lt;:AbstractFloat"><code>Titus.getYIonModifier</code></a></li><li><a href="#Titus.matchPeaks-Union{Tuple{U}, Tuple{T}, Tuple{Vector{Transition}, Array{Union{Missing, T}, 1}, Array{Union{Missing, T}, 1}}} where {T, U&lt;:AbstractFloat}"><code>Titus.matchPeaks</code></a></li><li><a href="#Titus.matchPeaks!-Union{Tuple{U}, Tuple{T}, Tuple{Array{FragmentMatch{T}, 1}, Vector{Transition}, Array{Union{Missing, T}, 1}, Array{Union{Missing, T}, 1}, U, UInt32, UInt32}} where {T, U&lt;:AbstractFloat}"><code>Titus.matchPeaks!</code></a></li><li><a href="#Titus.setFragmentMatch!-Union{Tuple{T}, Tuple{Array{FragmentMatch{T}, 1}, Int64, Transition, T, T, Int64, UInt32, UInt32}} where T&lt;:AbstractFloat"><code>Titus.setFragmentMatch!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Titus.FragmentMatch" href="#Titus.FragmentMatch"><code>Titus.FragmentMatch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FragmentMatch</code></pre><p>Type that represents a match between a fragment ion and a mass spectrum peak</p><p><strong>Fields</strong></p><ul><li>transition::Transition – Represents a fragment ion</li><li>intensity::Float32 – Intensity of the matching peak</li><li>match_mz::Float32 – M/Z of the matching empirical peak.    NOT the transition mass and may differ from getMZ(transition) by some error</li><li>count::UInt8 – Number of matches (may want to count the number of matches if the spectrum is researched at    different mass offsets, such as in a cross correlation score)</li><li>peak_int::Int64 – Index of the matching peak in the mass spectrum. </li></ul><p><strong>Examples</strong></p><ul><li>`FragmentMatch(transition::Transition, intensity::Float32, mass::Float32, count::UInt8, peak_ind::Int64) –    default internal constructor</li><li><code>FragmentMatch()</code> – constructor for null/empty precursor</li></ul><p><strong>GetterMethods</strong></p><ul><li>getMZ(f::FragmentMatch) = getMZ(f.transition)</li><li>getLow(f::FragmentMatch) = getLow(f.transition)</li><li>getHigh(f::FragmentMatch) = getHigh(f.transition)</li><li>getPrecID(f::FragmentMatch) = getPrecID(f.transition)</li><li>getCharge(f::FragmentMatch) = getCharge(f.transition)</li><li>getIsotope(f::FragmentMatch) = getIsotope(f.transition)</li><li>getIonType(f::FragmentMatch) = getIonType(f.transition)</li><li>getInd(f::FragmentMatch) = getInd(f.transition)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/matchpeaks.jl#L2-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Ion" href="#Titus.Ion"><code>Titus.Ion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Ion</code></pre><p>Abstract type that represents an ion </p><p>Types that inherit from <code>Ion</code> should implement the following. </p><ul><li>getMZFeature(ion::Ion) = ion.mz</li><li>getMZ(ion::Ion) = getMZ(getMZFeature(ion))</li><li>getLow(ion::Ion) = getLow(getMZFeature(ion))</li><li>getHigh(ion::Ion) = getHigh(getMZFeature(ion))</li><li>getPrecID(ion::Ion) = ion.prec_id</li><li>getCharge(ion::Ion) = ion.charge</li><li>getIsotope(ion::Ion) = ion.isotope</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/precursor.jl#L210-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.MzFeature" href="#Titus.MzFeature"><code>Titus.MzFeature</code></a> — <span class="docstring-category">Type</span></header><section><div><p>MzFeature</p><p>Type that represents an m/z ratio with a ppm tolerance</p><p><strong>Fields</strong></p><ul><li>mono::Float32 – MZ with upper and lower bounds given a ppm tolerance</li><li>low::Float32 – Identifier of the precursor ion (parent ion of the fragment/transition)</li><li>high::Float32 – Type of transition. For example &#39;b&#39; for b ion or &#39;y&#39; for y ion</li></ul><p><strong>Examples</strong></p><ul><li><code>MzFeature(mono::Float32; ppm::Float32 = Float32(20))</code> – default internal constructor</li><li><code>MzFeature() = MzFeature(Float32(0.0))</code> – constructor for a default/placeholder MzFeature</li></ul><p><strong>GetterMethods</strong></p><ul><li>getMZ(mz<em>feature::MzFeature) = mz</em>feature.mono</li><li>getLow(mz<em>feature::MzFeature) = mz</em>feature.low</li><li>getHigh(mz<em>feature::MzFeature) = mz</em>feature.high</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/precursor.jl#L173-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Precursor" href="#Titus.Precursor"><code>Titus.Precursor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Precursor &lt;: Ion</p><p>Type that represents a precursor (A peptide parent ion)</p><p><strong>Fields</strong></p><ul><li>residues::Vector{Residue} – List of amino acid residues of the precursor in their appropriate order</li><li>mz::MzFeature – MZ with upper and lower bounds given a ppm tolerance</li><li>prec_id::UInt32 – Identifier of the precursor ion (parent ion of the fragment/transition)</li><li>charge::UInt8 – Charge of the fragment ion</li><li>isotope::UInt8 – Difference in number of neutrons from the monoisotopic fragment </li><li>pep_id::UInt32 – Identifier of the peptide from which precursor is derived</li></ul><p><strong>Examples</strong></p><ul><li><code>Precursor(residues::Vector{Residue}, mz::Float32, charge::UInt8,             isotope::UInt8,             pep_id::UInt32,            prec_id::UInt32;             ppm = Float32(20))</code> – default internal constructor</li><li><code>Precursor()</code> – constructor for null/empty precursor</li><li><code>Precursor(residues::Vector{Residue}, charge::UInt8,             isotope::UInt8 = UInt8(0),             pep_id::UInt32 = UInt32(0),            prec_id::UInt32 = UInt32(0)</code> – Constructor that calculates mz without having to supply it</li><li><code>Precursor(sequence::String; mods_dict::Dict{String, Float32} = Dict{String, Float32}(), charge::UInt8 = UInt8(2),             isotope::UInt8 = UInt8(0),             pep_id::UInt32 = UInt32(0),            prec_id::UInt32 = UInt32(0))</code> – Constructor that accepts a string representation of a peptide</li></ul><p><strong>GetterMethods</strong></p><ul><li>getResidues(precursor::Precursor) = precursor.residues</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/precursor.jl#L313-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Precursor-Tuple{}" href="#Titus.Precursor-Tuple{}"><code>Titus.Precursor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Precursor()
Constructor for an &quot;empty&quot; or &quot;default&quot; precursor</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/precursor.jl#L402-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Precursor-Union{Tuple{String}, Tuple{T}} where T&lt;:AbstractFloat" href="#Titus.Precursor-Union{Tuple{String}, Tuple{T}} where T&lt;:AbstractFloat"><code>Titus.Precursor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Precursor(sequence::String, mods_dict::Dict{String, Float32}, charge::Int32, isotope::Int32 = Int32(0), prec_id::Int32 = Int32(0), pep_id::Int32 = Int32(0))</code></pre><p>Alternate constructor for the <code>Precursor</code> struct. Can accept a string representation of a peptide and a <code>mods_dict</code>  and convert to residues <code>Array{Residue, 1}</code>.  (link to Precusor)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/precursor.jl#L388-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Precursor-Union{Tuple{T}, Tuple{Array{Residue{T}, 1}, UInt8}, Tuple{Array{Residue{T}, 1}, UInt8, UInt8}, Tuple{Array{Residue{T}, 1}, UInt8, UInt8, UInt32}, Tuple{Array{Residue{T}, 1}, UInt8, UInt8, UInt32, UInt32}} where T&lt;:AbstractFloat" href="#Titus.Precursor-Union{Tuple{T}, Tuple{Array{Residue{T}, 1}, UInt8}, Tuple{Array{Residue{T}, 1}, UInt8, UInt8}, Tuple{Array{Residue{T}, 1}, UInt8, UInt8, UInt32}, Tuple{Array{Residue{T}, 1}, UInt8, UInt8, UInt32, UInt32}} where T&lt;:AbstractFloat"><code>Titus.Precursor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Precursor(residues::Array{Residue, 1}, charge::Int32, isotope::Int32 = Int32(0), prec_id::Int32 = Int32(0), pep_id::Int32 = Int32(0))</code></pre><p>Constructor for the <code>Precursor</code> struct. Given a list of amino acid residues, a charge, and an isotope state, makes a precursor object with the correct mz.  (link to Precursor)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/precursor.jl#L370-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Residue" href="#Titus.Residue"><code>Titus.Residue</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Residue</p><p>Type that represents a (potentially modified) amino acid within a peptide</p><p><strong>Fields</strong></p><ul><li>mass:Float32 – mass of the amino acid</li></ul><p><strong>Examples</strong></p><ul><li><code>Residue(aa::AA)</code> – default constructor</li><li><code>Residue(aa::Char) = Residue(AA(aa))</code></li><li><code>Residue(aa::AA, mod::Mod) = Residue(getMass(mod)+getMass(aa))</code></li><li><code>Residue(residue::String, mods_dict::Dict{String, Float32}) = Residue(AA(residue[1]), Mod(residue, mods_dict))</code></li><li><code>Residue(residue::String) = Residue(residue, Dict{String, Float32}())</code></li><li><code>Residue(residue::String, mod_mass::Float32) = Residue(getMass(AA(residue[1])) + mod_mass)</code></li><li><code>Residue(residue::Char, mod_mass::Float32) = Residue(getMass(AA(residue)) + mod_mass)</code></li></ul><p><strong>Getter methods</strong></p><ul><li>getMass(residue::Residue) = residue.mass</li></ul><p><strong>See Also</strong></p><ul><li><code>getResidues(sequence::String,               mods_dict::Dict{String, Float32} = default_mods)</code> – Gets a vector of residues given a string  representation of an amino acid sequence</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/precursor.jl#L103-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Transition" href="#Titus.Transition"><code>Titus.Transition</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Transition &lt;: Ion</p><p>Type that represents transition (fragment ion of a peptide)</p><p><strong>Fields</strong></p><ul><li>mz::MzFeature – MZ with upper and lower bounds given a ppm tolerance</li><li>prec_id::UInt32 – Identifier of the precursor ion (parent ion of the fragment/transition)</li><li>ion_type::Char  – Type of transition. For example &#39;b&#39; for b ion or &#39;y&#39; for y ion</li><li>ind::UInt8 – Position of fragment ion with reference to parent ion. (A b5+2 ion should have an ind equal to 5)</li><li>charge::UInt8 – Charge of the fragment ion</li><li>isotope::UInt8 – Difference in number of neutrons from the monoisotopic fragment </li></ul><p><strong>Examples</strong></p><ul><li><code>Transition(frag_mz::Float32, prec_id::UInt32, ion_type::Char, ind::UInt8,              charge::UInt8,              isotope::UInt8;              ppm = Float32(20))</code> – default internal constructor</li><li><code>Transition(residues::Vector{Residue}; ion_type::Char = &#39;y&#39;, charge::UInt8 = UInt8(1),              ind::UInt8 = UInt8(length(residues)),              isotope::UInt8 = UInt8(0),              prec_id::UInt32 = UInt32(0))</code> – constructor that calculates the appropriate mz</li></ul><p><strong>GetterMethods</strong></p><ul><li>getIonType(transition::Transition) = transition.ion_type</li><li>getInd(transition::Transition) = transition.ind</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/precursor.jl#L236-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.Transition-Union{Tuple{Array{Residue{T}, 1}}, Tuple{T}} where T&lt;:AbstractFloat" href="#Titus.Transition-Union{Tuple{Array{Residue{T}, 1}}, Tuple{T}} where T&lt;:AbstractFloat"><code>Titus.Transition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Transition(residues::Vector{Residue}; ion_type::Char = &#39;y&#39;, charge::UInt8 = UInt8(1), ind::UInt8 = UInt8(length(residues)), isotope::UInt8 = UInt8(0), prec_id::UInt32 = UInt32(0))

Constructor for the `Transition` struct. Given a list of amino acid residues, ion type (b or y), charge state, and isotopic state makes a transition with the correct mz.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/precursor.jl#L283-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.getBIonModifier-Union{Tuple{UInt8}, Tuple{T}, Tuple{UInt8, T}} where T&lt;:AbstractFloat" href="#Titus.getBIonModifier-Union{Tuple{UInt8}, Tuple{T}, Tuple{UInt8, T}} where T&lt;:AbstractFloat"><code>Titus.getBIonModifier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getBIonModifier(charge::UInt8)</code></pre><p>Mass modification that needs to be added to b-ions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/precursor.jl#L418-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.getFragIons-Union{Tuple{Array{Residue{T}, 1}}, Tuple{T}} where T&lt;:AbstractFloat" href="#Titus.getFragIons-Union{Tuple{Array{Residue{T}, 1}}, Tuple{T}} where T&lt;:AbstractFloat"><code>Titus.getFragIons</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getFragIons(residues::Vector{Residue}; charge::UInt8 = UInt8(1), isotope::UInt8 = UInt8(0), y_start::Int = 3, b_start::Int = 3)</code></pre><p>Uses calls to <code>getIonSeries</code> to concatenate both the b and y ion series together in a single Vector{Float32}</p><p><strong>Input</strong></p><ul><li><code>residues::Vector{Residue}</code>: – List of amino acid residues in the peptide ion</li><li><code>charge::UInt8</code> – Charge of the fragment ions</li><li><code>b_start::Int=3</code>  – Index of first ion the the b-ion series to compute. </li><li><code>y_start::Int=3</code>  – Index of first ion the the y-ion series to compute. </li><li><code>isotope::UInt8=UInt8(0)</code> – Diference in the number of isotopes from the monoisotopic ion. </li></ul><p><strong>Output</strong></p><p>A Vector{Float32} wich each m/z in the ion series</p><p><strong>Notes</strong></p><ul><li>The <code>modifier</code> argument ought to depend on the kind of ion. For a &#39;b&#39; ion series PROTON*charge is appropriate,</li></ul><p>but for a &#39;y&#39; ion series, PROTON*charge + H2O would be appropriate. </p><ul><li>Will not allow the index of the ion to be equal to or less than the charge. For example,</li></ul><p>b2+2 ions could only be calculated in error and are therefore excluded even if <code>start</code>  is set to 2. </p><ul><li>If <code>start</code> exceeds length(residues)-1, then only the N-1 ion is calculated, that is,</li></ul><p>the highest mass ion in the series. </p><p><strong>Examples</strong></p><p>#Gets the b3+1-b6+1 and y3+1-y6+1 ions</p><pre><code class="language-julia-repl hljs">julia&gt; getFragIons(reverse(getResidues(&quot;PEPTIDE&quot;)), b_start = 3, y_start = 3)
8-element Vector{Float32}:
 358.16083
 459.2085
 556.2612
 685.30383
 342.16595
 443.21365
 556.29767
 671.3246</code></pre><p><strong>See Also</strong></p><p>Alternate convience methods</p><ul><li><p><code>getFragIons(residues::Vector{Residue}; charge::UInt8 = UInt8(1),             isotope::UInt8 = UInt8(0),              y_start::Int = 3,              b_start::Int = 3)</code> - Default method</p></li><li><p><code>getFragIons(precursor::Precursor; charge::UInt8 = UInt8(1),              isotope::UInt8 = UInt8(0),              y_start::Int = 3,              b_start::Int = 3)</code> - Can supply a <code>Precursor</code> rather than a  <code>Vector{Residues}</code> input</p></li><li><p><code>getFragIons(precursor::Precursor,charges::Vector{UInt8},              isotopes::Vector{UInt8};              y_start::Int = 3,              b_start::Int = 3)</code> - Gets b and y ion seriers for multiple charge and isotopic states</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/precursor.jl#L604-L666">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.getIonMZ-Union{Tuple{T}, Tuple{Array{Residue{T}, 1}, Char, UInt8}} where T&lt;:AbstractFloat" href="#Titus.getIonMZ-Union{Tuple{T}, Tuple{Array{Residue{T}, 1}, Char, UInt8}} where T&lt;:AbstractFloat"><code>Titus.getIonMZ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getIonMZ(residues::Vector{Residue}, ion_type::Char, charge::UInt8; isotope::UInt8 = UInt8(0))</code></pre><p>Alternate getIonMZ method that chooses the correct mass modifier for &#39;b&#39;, &#39;y&#39;, and &#39;p&#39; ions respectively. </p><p><strong>Input</strong></p><pre><code class="nohighlight hljs">- `residues::Vector{Residue}`: -- List of amino acid residues in the peptide ion
- `ion_type::Char` -- Type of fragment ion. Currently supports, &#39;b&#39;, &#39;y&#39;, and &#39;p&#39;. 
- `charge::UInt8` -- Charge of the ion
- `isotope::UInt8=UInt8(0)` -- Diference in the number of isotopes from the monoisotopic ion.</code></pre><p><strong>Notes</strong></p><pre><code class="nohighlight hljs">See main method
    getIonMZ(residues::Vector{Residue}, charge::UInt8; modifier::Float32 = PROTON*charge + H2O, isotope::UInt8 = UInt8(0))
for more details</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/precursor.jl#L481-L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.getIonMZ-Union{Tuple{T}, Tuple{Array{Residue{T}, 1}, UInt8}} where T&lt;:AbstractFloat" href="#Titus.getIonMZ-Union{Tuple{T}, Tuple{Array{Residue{T}, 1}, UInt8}} where T&lt;:AbstractFloat"><code>Titus.getIonMZ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getIonMZ(residues::Vector{Residue}, charge::UInt8; modifier::Float32 = PROTON*charge + H2O, isotope::UInt8 = UInt8(0))::Float32</code></pre><p>Get the mz ratio of an ion</p><p><strong>Input</strong></p><ul><li><code>residues::Vector{Residue}</code>: – List of amino acid residues in the peptide ion</li><li><code>charge::UInt8</code> – Charge of the ion</li><li><code>modifier::Float32=PROTON*charge + H2O</code> – Added to the mass of the ion</li><li><code>isotope::UInt8=UInt8(0)</code> – Diference in the number of isotopes from the monoisotopic ion. </li></ul><p><strong>Output</strong></p><p>A Float32 representing the mass-to-charge ratio (m/z) of an ion</p><p><strong>Notes</strong></p><p>The <code>modifier</code> argument ought to depend on the kind of ion. For B ions PROTON<em>charge is appropriate, but for &#39;y&#39; or precursor ions, PROTON</em>charge + H2O would be appropriate.</p><p><strong>Algorithm</strong></p><p>Sum the amino acid residue masses, add <code>modifier</code> + isotope*NEUTRON and then divide the total by the charge. </p><p><strong>Examples</strong></p><p>#Gets the b6+1 ion MZ</p><pre><code class="language-julia-repl hljs">julia&gt; getIonMZ(getResidues(&quot;PEPTIDE&quot;)[1:6], UInt8(1), modifier = PROTON)
653.314f0</code></pre><p>#Gets the y6+1 ion MZ</p><pre><code class="language-julia-repl hljs">julia&gt; getIonMZ(reverse(getResidues(&quot;PEPTIDE&quot;))[1:6], UInt8(1))
703.3144f0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/precursor.jl#L434-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.getIonSeries-Union{Tuple{T}, Tuple{Array{Residue{T}, 1}, UInt8}} where T&lt;:AbstractFloat" href="#Titus.getIonSeries-Union{Tuple{T}, Tuple{Array{Residue{T}, 1}, UInt8}} where T&lt;:AbstractFloat"><code>Titus.getIonSeries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getIonSeries(residues::Vector{Residue}, charge::UInt8; start::Int = 3, modifier::Float32 = PROTON*charge + H2O, isotope::UInt8 = UInt8(0))</code></pre><p>Gets the m/z&#39;s for an ion series as a Vector{Float32}. </p><p><strong>Input</strong></p><ul><li><code>residues::Vector{Residue}</code>: – List of amino acid residues in the peptide ion</li><li><code>charge::UInt8</code> – Charge of the fragment ions</li><li><code>start::Int=3</code>  – Index of first ion the the series to compute.</li><li><code>isotope::UInt8=UInt8(0)</code> – Diference in the number of isotopes from the monoisotopic ion. </li></ul><p><strong>Output</strong></p><p>A Vector{Float32} wich each m/z in the ion series</p><p><strong>Notes</strong></p><ul><li>The <code>modifier</code> argument ought to depend on the kind of ion. For a &#39;b&#39; ion series PROTON*charge is appropriate,</li></ul><p>but for a &#39;y&#39; ion series, PROTON*charge + H2O would be appropriate. </p><ul><li>Will not allow the index of the ion to be equal to or less than the charge. For example,</li></ul><p>b2+2 ions could only be calculated in error and are therefore excluded even if <code>start</code>  is set to 2. </p><ul><li>If <code>start</code> exceeds length(residues)-1, then only the N-1 ion is calculated, that is,</li></ul><p>the highest mass ion in the series. </p><p><strong>Examples</strong></p><p>#Gets the y3+2 through y6+2 ions</p><pre><code class="language-julia-repl hljs">julia&gt; getIonSeries(reverse(getResidues(&quot;PEPTIDE&quot;)), UInt8(2), start = 3)
4-element view(::Vector{Float32}, 3:6) with eltype Float32:
 188.58934
 239.11317
 287.63956
 352.16086</code></pre><p>#Gets the b4+2 through b6+2 ions</p><pre><code class="language-julia-repl hljs">julia&gt; getIonSeries(getResidues(&quot;PEPTIDE&quot;), UInt8(2), start = 4, modifier = PROTON*UInt8(2))
3-element view(::Vector{Float32}, 4:6) with eltype Float32:
 213.10518
 269.6472
 327.16064</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/precursor.jl#L539-L587">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.getNearest-Union{Tuple{U}, Tuple{T}, Tuple{Transition, Array{Union{Missing, T}, 1}, Int64}} where {T, U&lt;:AbstractFloat}" href="#Titus.getNearest-Union{Tuple{U}, Tuple{T}, Tuple{Transition, Array{Union{Missing, T}, 1}, Int64}} where {T, U&lt;:AbstractFloat}"><code>Titus.getNearest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getNearest(transition::Transition, masses::Vector{Union{Missing, Float32}}, peak::Int; δ = 0.01)</code></pre><p>Finds the <code>peak</code> (index of <code>masses</code>) nearest in mass to the <code>transition</code> but still within the tolerance (getLow(transition)&lt;masses[peak]&lt;getHigh(transition)).  Starts searching at initially supplied <code>peak</code> and increases the index until outside the tolerance. There could be multiple peaks within the tolerance,  and this function selects the one with the lowest mass error to the fragment ion. </p><p><strong>Input</strong></p><ul><li><code>transition::Transition</code>: – Represents a fragment ion</li><li><code>masses::Vector{Union{Missing, Float32}}</code> – Mass list from a centroided mass spectrum. MUST BE SORTED IN ASCENDING ORDER. </li><li><code>peak::Int</code> – An index for a mass in <code>masses</code></li><li><code>δ</code> – A mass offset that can be applied to each mass in <code>masses</code> </li></ul><p><strong>Output</strong></p><p>An Int representing the index of the m/z in <code>masses</code> nearest in m/z to that of the fragment m/z. </p><p><strong>Notes</strong></p><ul><li>It is assumed that masses is sorted in ascending order. </li><li>In practice, when called from <code>matchPeaks!</code>, masses[peak] will already be within the fragment m/z tolerance.</li></ul><p>Usually there will not be another peak in <code>masses</code> where this is true, but it is possible for multiple peaks to  fall within the tolerance. The purpose of this function is to select the best peak (closes in mass) when this happens.  </p><p><strong>Algorithm</strong></p><p><strong>Examples</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/matchpeaks.jl#L62-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.getPrecursors-Union{Tuple{Array{Residue{T}, 1}}, Tuple{T}} where T&lt;:AbstractFloat" href="#Titus.getPrecursors-Union{Tuple{Array{Residue{T}, 1}}, Tuple{T}} where T&lt;:AbstractFloat"><code>Titus.getPrecursors</code></a> — <span class="docstring-category">Method</span></header><section><div><p>getPrecursors(residues::Vector{Residue}; charges::Vector{UInt8} = UInt8[1,2],isotopes::Vector{UInt8}=UInt8[0],pep_id::UInt32=UInt32(0)) </p><p>Alternate constructor for the <code>Precursor</code> struct that Can accept a string representation of a peptide</p><p><strong>Input</strong></p><p><strong>Output</strong></p><p><strong>Notes</strong></p><p>(link to getResidues())</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/precursor.jl#L518-L530">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.getYIonModifier-Union{Tuple{UInt8}, Tuple{T}, Tuple{UInt8, T}, Tuple{UInt8, T, T}} where T&lt;:AbstractFloat" href="#Titus.getYIonModifier-Union{Tuple{UInt8}, Tuple{T}, Tuple{UInt8, T}, Tuple{UInt8, T, T}} where T&lt;:AbstractFloat"><code>Titus.getYIonModifier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getYIonModifier(charge::UInt8)</code></pre><p>Mass modification that needs to be added to y-ions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/precursor.jl#L426-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.matchPeaks!-Union{Tuple{U}, Tuple{T}, Tuple{Array{FragmentMatch{T}, 1}, Vector{Transition}, Array{Union{Missing, T}, 1}, Array{Union{Missing, T}, 1}, U, UInt32, UInt32}} where {T, U&lt;:AbstractFloat}" href="#Titus.matchPeaks!-Union{Tuple{U}, Tuple{T}, Tuple{Array{FragmentMatch{T}, 1}, Vector{Transition}, Array{Union{Missing, T}, 1}, Array{Union{Missing, T}, 1}, U, UInt32, UInt32}} where {T, U&lt;:AbstractFloat}"><code>Titus.matchPeaks!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function matchPeaks!(matches::Vector{FragmentMatch}, Transitions::Vector{Transition}, masses::Vector{Union{Missing, Float32}}, intensities::Vector{Union{Missing, Float32}}, δ::Float64)</code></pre><p>Finds the best matching peak in a mass spectrum for each transition/fragment ion supplied if the match is within the fragment tolerance.      Adds each FragmentMatch to <code>matches</code> if not already present. Otherwise,      modifies an existing match (see setFragmentMatch!).</p><p><strong>Input</strong></p><ul><li><code>matches::Vector{FragmentMatch}</code>: – A list representing fragment ions that match peaks in the mass spectrum (<code>masses</code>)</li><li><code>Transitions::Vector{Transition</code> – A list of fragment ions to search for in the spectrum (<code>masses</code>). MUST BE SORTED IN ASCENDING ORDER BY <code>getMZ(transition)</code></li><li><code>masses::Vector{Union{Missing, Float32}}</code> – Mass list from a centroided mass spectrum. MUST BE SORTED IN ASCENDING ORDER.</li><li><code>intensities::Vector{Union{Missing, Float32}}</code> – The intensity list from a centroided mass spectrum. Must be the same length as <code>masses</code></li><li><code>δ::Float64</code> – A mass offset that can be applied to each mass in <code>masses</code></li></ul><p><strong>Output</strong></p><p>Modifies <code>matches[match]</code> if match is &lt;= lenth(matches). Otherwise adds a new FragmentMatch at <code>matches[match]</code></p><p><strong>Notes</strong></p><ul><li>Updating a match in <code>matches</code> could be useful if researching the same spectra many times at different mass offsets with <code>matchPeaks!</code>    This could be done to calculate a cross correlatoin score for example. If a spectrum is only searched once, then matches should   only be added to <code>matches</code> and existing ones never modified. </li><li>The fragment tolerance is specified by each <code>Transition</code>. A <code>Transition&lt;:Ion</code> has a field <code>mz::MzFeature</code> which specifies the monoisotopic mass   and also upper and lower bounds (the tolerance). See getLow(ion::Ion) and getHigh(ion::Ion). This is why the user need not supply a fragment tolerance to <code>matchPeaks!</code> </li><li><code>masses</code> and <code>intensities</code> contain type unions Union{Missing, Float32}. This method does nothing to check for Missing values, and indeed,   it is assumed that there are none, and the presence of any Missing values will cause an error. The reason for the type union is an idiosyncracy   of the Arrow.jl package and how it implements nested data types in Arrow files. </li></ul><p><strong>Algorithm</strong></p><p>Given a list of fragment ions and a centroided mass spectrum both sorted by m/z, it is efficient to search the spetrum for matches in a &quot;single pass&quot; through the spectrum. If there are T transitions and P peaks should be O(T+P). If there are multiple peaks within the tolerance for a given  fragment ion, the peak closest in m/z to the fragment ion is chosen. It is possible to assign the same peak to multiple fragment ions, but  each fragment ion is only assigned to 0 or 1 peaks. </p><p><strong>Examples</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/matchpeaks.jl#L162-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.matchPeaks-Union{Tuple{U}, Tuple{T}, Tuple{Vector{Transition}, Array{Union{Missing, T}, 1}, Array{Union{Missing, T}, 1}}} where {T, U&lt;:AbstractFloat}" href="#Titus.matchPeaks-Union{Tuple{U}, Tuple{T}, Tuple{Vector{Transition}, Array{Union{Missing, T}, 1}, Array{Union{Missing, T}, 1}}} where {T, U&lt;:AbstractFloat}"><code>Titus.matchPeaks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function matchPeaks!(matches::Vector{FragmentMatch}, Transitions::Vector{Transition}, masses::Vector{Union{Missing, Float32}}, intensities::Vector{Union{Missing, Float32}}, δ::Float64)</code></pre><p>A wrapper for calling <code>matchPeaks</code> at different to search spectra at a list of mass offset.      Each all to <code>matchPeaks</code> Finds the best matching peak in a mass spectrum for each transition/fragment ion supplied if the match is within the fragment tolerance.      Adds each FragmentMatch to <code>matches</code> if not already present. Otherwise, modifies an existing match (see setFragmentMatch!). (see <code>matchPeaks</code> for additional details)</p><p><strong>Input</strong></p><ul><li><code>matches::Vector{FragmentMatch}</code>: – A list representing fragment ions that match peaks in the mass spectrum (<code>masses</code>)</li><li><code>Transitions::Vector{Transition</code> – A list of fragment ions to search for in the spectrum (<code>masses</code>). MUST BE SORTED IN ASCENDING ORDER BY <code>getMZ(transition)</code></li><li><code>masses::Vector{Union{Missing, Float32}}</code> – Mass list from a centroided mass spectrum. MUST BE SORTED IN ASCENDING ORDER.</li><li><code>intensities::Vector{Union{Missing, Float32}}</code> – The intensity list from a centroided mass spectrum. Must be the same length as <code>masses</code></li><li><code>δ::Float64</code> – A mass offset that can be applied to each mass in <code>masses</code></li></ul><p><strong>Output</strong></p><p>Modifies <code>matches[match]</code> if match is &lt;= lenth(matches). Otherwise adds a new FragmentMatch at <code>matches[match]</code></p><p><strong>Notes</strong></p><ul><li>Searching a mass spectrum many times at different mass offsets could be useful for caculating cross correlation scores. </li></ul><p><strong>Algorithm</strong></p><pre><code class="nohighlight hljs">See `matchPeaks`</code></pre><p><strong>Examples</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/matchpeaks.jl#L230-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Titus.setFragmentMatch!-Union{Tuple{T}, Tuple{Array{FragmentMatch{T}, 1}, Int64, Transition, T, T, Int64, UInt32, UInt32}} where T&lt;:AbstractFloat" href="#Titus.setFragmentMatch!-Union{Tuple{T}, Tuple{Array{FragmentMatch{T}, 1}, Int64, Transition, T, T, Int64, UInt32, UInt32}} where T&lt;:AbstractFloat"><code>Titus.setFragmentMatch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setFragmentMatch!(matches::Vector{FragmentMatch}, match::Int, transition::Transition, mass::Float32, intensity::Float32, peak_ind::Int64)</code></pre><p>Adds a FragmentMatch to <code>matches</code> if <code>match</code> is not an index in <code>matches</code>, otherwise, updates the match.</p><p><strong>Input</strong></p><ul><li><code>hits::Vector{FragmentMatch}</code>: – Represents a fragment ion</li><li><code>match::Int</code> – Index of the match. Must be &lt;=N+1 where N is length(hits) </li><li><code>mass::Float32</code> – m/z of the emperical peak matched to the transition</li><li><code>intensity::Float32</code> – intensity of the emperical peak matched to the transition</li><li><code>peak_ind</code> – unique index of the emperical peak matched to the transition</li></ul><p><strong>Output</strong></p><p>Modifies <code>matches[match]</code> if match is &lt;= lenth(matches). Otherwise adds a new FragmentMatch at <code>matches[match]</code></p><p><strong>Notes</strong></p><ul><li>Updating a match in <code>matches</code> could be useful if researching the same spectra many times at different mass offsets with <code>matchPeaks!</code>    This could be done to calculate a cross correlatoin score for example. If a spectrum is only searched once, then matches should   only be added to <code>matches</code> and existing ones never modified. </li><li>Recording the <code>peak_ind</code> could be useful, for example, &quot;chimeric&quot; scoring of a spectrum from a Vector{FragmentMatch} type. The best scoring precursor would   have fragments matching to known <code>peak_ind</code>. The Vector{FragmentMatch} could be rescored but excluding FragmentMatches corresponding   to those peak_ind&#39;s. This would enable a simple chimeric spectra scoring that would not involve completely researching the spectrum (making an additional call to <code>matchPeaks</code>). </li></ul><p><strong>Algorithm</strong></p><p><strong>Examples</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/nwamsley1/Titus.jl/blob/946e54d8b854ffca2051936f87ea99c309dbb225/src/matchpeaks.jl#L116-L146">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="examples/test/">« -</a><a class="docs-footer-nextpage" href="license/">License »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 30 May 2023 22:08">Tuesday 30 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
